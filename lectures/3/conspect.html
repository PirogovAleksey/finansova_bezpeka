<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Конспект лекції 3: Автентифікація та контроль доступу у фінансових системах.">
  <meta name="author" content="Кафедра ТЕІБ, Ужгородський національний університет">
  <meta name="theme-color" content="#0ea5e9">
  <title>Конспект: Лекція 3 — Фінансова Безпека</title>
  <link rel="icon" type="image/svg+xml" href="../../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../css/style.css">
  <script>if(localStorage.getItem('theme')==='dark')document.documentElement.classList.add('dark')</script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
          <path d="M9 12l2 2 4-4"/>
        </svg>
      </div>
      <div class="logo-text">
        Фінансова<br>Безпека
        <span>онлайн-курс</span>
      </div>
    </div>

    <nav aria-label="Головна навігація">
      <a href="../../index.html" class="active">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../../practicals.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>
        Практичні
      </a>
      <a href="../../tests.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../../materials.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
    </nav>

    <div class="sidebar-footer">
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <main>
    <div class="lecture-nav-top">
      <a href="../../lecture.html?id=3" class="back-link">&larr; Назад до лекції 3</a>
      <span class="lecture-badge">Конспект лекції 3</span>
    </div>

    <article class="lecture-content">
      <h1>Автентифікація та контроль доступу</h1>
      <div class="lecture-info">
        <span>⏱ 2 год</span>
        <span class="badge badge-new">Конспект</span>
      </div>

      <!-- Section 3.1 -->
      <section>
        <h2>3.1 Механізми автентифікації у фінансовому секторі</h2>

        <p>Автентифікація — це процес підтвердження ідентичності користувача або системи. У фінансовому секторі автентифікація є першою лінією оборони: саме вона стоїть між зловмисником та доступом до рахунків, транзакцій і конфіденційних даних клієнтів. За даними Verizon Data Breach Investigations Report 2024, понад 80% зламів, пов'язаних з веб-додатками, використовують скомпрометовані або слабкі облікові дані.</p>

        <p><strong>Три фактори автентифікації:</strong></p>
        <ul>
          <li><strong>Щось, що ви знаєте (Knowledge)</strong> — пароль, PIN-код, секретне питання. Це найпоширеніший, але найслабший фактор: паролі можна вгадати, перехопити, вкрасти через фішинг або отримати з витоків даних.</li>
          <li><strong>Щось, що ви маєте (Possession)</strong> — апаратний токен, смартфон із TOTP-додатком, смарт-картка, USB-ключ FIDO2. Фізичне володіння пристроєм значно ускладнює атаку.</li>
          <li><strong>Щось, що ви є (Inherence)</strong> — біометричні дані: відбиток пальця, розпізнавання обличчя (Face ID), сканування сітківки, голосова верифікація.</li>
        </ul>

        <p><strong>Проблеми паролів у фінансовому секторі.</strong> Незважаючи на десятиліття рекомендацій щодо складності паролів, вони залишаються найслабшою ланкою. Дослідження NordPass показує, що «123456» залишається найпопулярнішим паролем у світі. У фінансовому секторі це особливо небезпечно: credential stuffing атаки використовують бази витоків (понад 15 мільярдів скомпрометованих облікових записів в інтернеті) для автоматичного підбору паролів до банківських акаунтів. Рекомендації NIST SP 800-63B відмовились від примусової зміни паролів кожні 90 днів та вимог до спеціальних символів, натомість рекомендуючи довгі парольні фрази та перевірку паролів на наявність у базах витоків.</p>

        <p><strong>Multi-Factor Authentication (MFA)</strong> — це вимога двох або більше факторів для підтвердження ідентичності. Основні методи MFA у фінансових системах:</p>
        <ul>
          <li><strong>TOTP (Time-based One-Time Password)</strong> — генерація одноразових кодів, що змінюються кожні 30 секунд (Google Authenticator, Authy). Базується на спільному секреті та поточному часі. Переваги: працює офлайн, не залежить від мобільної мережі. Недоліки: вразливий до фішингу в реальному часі (зловмисник може перехопити код і використати його).</li>
          <li><strong>FIDO2/WebAuthn</strong> — стандарт безпарольної автентифікації з використанням криптографії з публічним ключем. Приватний ключ зберігається на пристрої (YubiKey, Touch ID, Windows Hello) і ніколи не передається серверу. Ключова перевага: повна стійкість до фішингу — автентифікація прив'язана до конкретного домену (origin binding), тому підроблений сайт не зможе перехопити credentials.</li>
          <li><strong>Push-нотифікації</strong> — додаток на смартфоні показує деталі операції і просить підтвердити або відхилити. Використовується у багатьох банківських додатках (Приват24, monobank). Ризик: MFA fatigue attacks — зловмисник надсилає десятки push-запитів, доки користувач випадково не натисне «Підтвердити» (атака на Uber у 2022 році).</li>
          <li><strong>SMS OTP</strong> — одноразовий код через SMS. Найпоширеніший, але найменш безпечний метод MFA: вразливий до SIM-swapping (зловмисник переносить номер жертви на свою SIM-картку), SS7-атак та перехоплення SMS. NIST визнає SMS OTP небажаним методом (restricted authenticator).</li>
        </ul>

        <p><strong>Біометрична автентифікація у банкінгу.</strong> Біометрія активно впроваджується у фінансовому секторі. ПриватБанк використовує Face ID для підтвердження транзакцій, monobank — відбиток пальця. Mastercard тестує оплату з розпізнаванням обличчя на касах. Важливі аспекти: біометричні дані не можна замінити (на відміну від пароля, відбиток пальця не змінити після витоку), тому вони повинні зберігатися лише локально на пристрої або у зашифрованому вигляді. Liveness detection запобігає атакам з фотографіями та масками.</p>

        <p><strong>Passwordless-автентифікація</strong> — майбутнє фінансової автентифікації. Стандарт Passkeys (FIDO Alliance + Apple/Google/Microsoft) дозволяє входити в акаунт без пароля, використовуючи біометрію пристрою або PIN. Ключі синхронізуються між пристроями через хмару (iCloud Keychain, Google Password Manager). Банки поступово впроваджують passkeys: у 2024 році кілька великих фінансових установ (Paypal, Kayak) запустили підтримку passkeys для входу.</p>

        <h3>Технічний приклад: Хешування паролів за допомогою bcrypt</h3>
        <p>Фінансові системи ніколи не зберігають паролі у відкритому вигляді. Замість цього використовується адаптивне хешування (bcrypt, Argon2), яке навмисно повільне для ускладнення brute-force атак:</p>
        <pre><code># Python — хешування паролів за допомогою bcrypt
import bcrypt

# Реєстрація: хешування пароля перед збереженням у БД
password = "SuperSecure_Passphrase_2024!".encode('utf-8')
salt = bcrypt.gensalt(rounds=12)  # cost factor 12 ≈ 250ms на хеш
hashed = bcrypt.hashpw(password, salt)
print(f"Хеш для збереження в БД: {hashed}")
# Результат: $2b$12$LJ3m4ys3Lg...  (60 символів)

# Автентифікація: перевірка введеного пароля
user_input = "SuperSecure_Passphrase_2024!".encode('utf-8')
if bcrypt.checkpw(user_input, hashed):
    print("Автентифікація успішна")
else:
    print("Невірний пароль")

# ВАЖЛИВО для фінансових систем:
# - rounds=12+ (мінімум для банківських додатків)
# - Argon2id рекомендований OWASP як сучасна альтернатива
# - Ніколи не використовуйте MD5/SHA-256 без salt для паролів
</code></pre>

        <h3>Технічний приклад: Генерація TOTP-кодів (Time-based One-Time Password)</h3>
        <p>TOTP — основа більшості MFA-рішень у банківських додатках. Алгоритм генерує 6-значний код кожні 30 секунд на основі спільного секрету та поточного часу (RFC 6238):</p>
        <pre><code># Python — генерація та перевірка TOTP за допомогою pyotp
import pyotp
import qrcode

# 1. Сервер генерує секрет при реєстрації MFA
secret = pyotp.random_base32()  # e.g., 'JBSWY3DPEHPK3PXP'
print(f"Секрет (зберігається на сервері зашифровано): {secret}")

# 2. Генерація QR-коду для сканування додатком (Google Authenticator)
totp = pyotp.TOTP(secret)
provisioning_uri = totp.provisioning_uri(
    name="user@privatbank.ua",
    issuer_name="PrivatBank Online"
)
print(f"URI для QR-коду: {provisioning_uri}")
# otpauth://totp/PrivatBank%20Online:user%40privatbank.ua?secret=JBSWY3DPEHPK3PXP&issuer=PrivatBank%20Online

# 3. Генерація поточного OTP (на стороні клієнта)
current_otp = totp.now()
print(f"Поточний OTP: {current_otp}")  # e.g., "482931"

# 4. Верифікація на сервері (з допуском ±1 інтервал для clock skew)
is_valid = totp.verify(current_otp, valid_window=1)
print(f"Код дійсний: {is_valid}")  # True

# Параметри безпеки для фінансових систем:
# - interval=30 (стандарт, менше — безпечніше, але незручно)
# - digits=6 (мінімум, деякі банки використовують 8)
# - algorithm=SHA-1 (стандарт), SHA-256 для підвищеної безпеки
</code></pre>

        <h3>Технічний приклад: Потік реєстрації WebAuthn (FIDO2)</h3>
        <p>WebAuthn забезпечує фішинг-стійку автентифікацію, прив'язуючи credential до конкретного домену. Нижче наведено спрощений потік реєстрації:</p>
        <pre><code>// JavaScript (браузер) — реєстрація WebAuthn credential

// Крок 1: Сервер генерує challenge та параметри
// GET /api/webauthn/register/options
const registrationOptions = {
  challenge: new Uint8Array([/* 32 випадкових байти від сервера */]),
  rp: {
    name: "PrivatBank Online",
    id: "privatbank.ua"           // Origin binding — захист від фішингу!
  },
  user: {
    id: new Uint8Array([/* user ID */]),
    name: "user@privatbank.ua",
    displayName: "Іван Петренко"
  },
  pubKeyCredParams: [
    { alg: -7,  type: "public-key" },  // ES256 (ECDSA)
    { alg: -257, type: "public-key" }  // RS256 (RSA)
  ],
  authenticatorSelection: {
    authenticatorAttachment: "cross-platform",  // YubiKey, etc.
    userVerification: "required",               // Біометрія обов'язкова
    residentKey: "required"                     // Discoverable credential (Passkey)
  },
  timeout: 60000,
  attestation: "direct"  // Запитати attestation від автентикатора
};

// Крок 2: Браузер викликає WebAuthn API
const credential = await navigator.credentials.create({
  publicKey: registrationOptions
});

// Крок 3: Відправка credential на сервер для збереження
// credential.response містить:
//   - clientDataJSON  (challenge, origin, type)
//   - attestationObject (публічний ключ, attestation)
const response = await fetch('/api/webauthn/register/verify', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    id: credential.id,
    rawId: btoa(String.fromCharCode(...new Uint8Array(credential.rawId))),
    response: {
      clientDataJSON: btoa(String.fromCharCode(
        ...new Uint8Array(credential.response.clientDataJSON)
      )),
      attestationObject: btoa(String.fromCharCode(
        ...new Uint8Array(credential.response.attestationObject)
      ))
    },
    type: credential.type
  })
});

// Сервер перевіряє:
// 1. challenge збігається з виданим
// 2. origin === "https://privatbank.ua" (захист від фішингу)
// 3. Підпис attestation валідний
// 4. Зберігає публічний ключ для подальшої автентифікації
</code></pre>

        <div class="control-questions">
          <h3>Контрольні запитання</h3>
          <ol>
            <li>Які три фактори автентифікації існують і чому для фінансових систем рекомендується комбінувати щонайменше два з них?</li>
            <li>Чому NIST SP 800-63B відмовився від вимоги примусової зміни паролів кожні 90 днів? Яку альтернативну стратегію пропонує стандарт?</li>
            <li>У чому полягає перевага FIDO2/WebAuthn перед TOTP з точки зору захисту від фішингових атак? Поясніть механізм origin binding.</li>
            <li>Що таке MFA fatigue attack і яким чином банківські додатки можуть захиститися від цього типу атаки?</li>
            <li>Чому біометричні дані повинні зберігатися локально на пристрої, а не на центральному сервері? Які ризики виникають при централізованому зберіганні біометрії?</li>
          </ol>
        </div>
      </section>

      <!-- Section 3.2 -->
      <section>
        <h2>3.2 Токени, сесії та протоколи автентифікації</h2>

        <p>Після успішної автентифікації система повинна «запам'ятати» користувача та надавати доступ без повторного введення credentials при кожному запиті. Для цього використовуються токени та сесії — механізми, що підтверджують ідентичність протягом певного часу.</p>

        <p><strong>JWT (JSON Web Token)</strong> — найпоширеніший формат токенів у сучасних веб-додатках та API. JWT складається з трьох частин, розділених крапкою:</p>
        <ol>
          <li><strong>Header</strong> — метадані токена: алгоритм підпису (HS256, RS256) та тип токена.</li>
          <li><strong>Payload</strong> — корисне навантаження: ідентифікатор користувача (sub), час видачі (iat), час закінчення (exp), ролі, дозволи та інші claims.</li>
          <li><strong>Signature</strong> — цифровий підпис, що гарантує цілісність токена. Для HMAC використовується спільний секрет, для RSA — приватний ключ сервера.</li>
        </ol>

        <p><strong>Вразливості JWT, критичні для фінансових систем:</strong></p>
        <ul>
          <li><strong>Algorithm None Attack</strong> — зловмисник змінює алгоритм у header на «none», і сервер приймає токен без перевірки підпису. Контрзахід: завжди перевіряти алгоритм на стороні сервера, використовувати whitelist дозволених алгоритмів.</li>
          <li><strong>Algorithm Confusion (RS256 → HS256)</strong> — якщо сервер підтримує обидва алгоритми, зловмисник може підписати токен публічним ключем RSA як HMAC-секретом. Контрзахід: фіксувати алгоритм для кожного ключа.</li>
          <li><strong>Відсутність перевірки exp</strong> — токен без терміну дії або з ігноруванням exp на сервері дає безстрокові права доступу.</li>
          <li><strong>Зберігання секретів у payload</strong> — payload лише закодований у Base64, а не зашифрований. Будь-хто може прочитати вміст.</li>
          <li><strong>Відсутність механізму відкликання (revocation)</strong> — JWT є stateless, тому скомпрометований токен неможливо анулювати до закінчення терміну дії. Рішення: короткий час життя access token (5-15 хвилин), blacklist відкликаних токенів, використання refresh token rotation.</li>
        </ul>

        <p><strong>OAuth 2.0</strong> — фреймворк делегованої авторизації, що дозволяє третім сторонам отримувати обмежений доступ до ресурсів без передачі пароля. У FinTech-контексті OAuth 2.0 критично важливий для Open Banking: клієнт може надати фінтех-додатку доступ до свого банківського акаунту без розкриття пароля банку.</p>
        <ul>
          <li><strong>Authorization Code Flow з PKCE</strong> — найбезпечніший flow, рекомендований для мобільних та SPA-додатків. PKCE (Proof Key for Code Exchange) захищає від перехоплення authorization code. Процес: клієнт генерує code_verifier → обчислює code_challenge → надсилає challenge на authorization server → обмінює code + verifier на токен.</li>
          <li><strong>Client Credentials Flow</strong> — для server-to-server взаємодії (наприклад, мікросервіс платежів звертається до сервісу верифікації). Клієнт автентифікується своїми credentials (client_id + client_secret) напряму.</li>
          <li><strong>Device Authorization Grant</strong> — для пристроїв без браузера (IoT-термінали, банкомати). Пристрій показує код, користувач вводить його на окремому пристрої.</li>
        </ul>

        <p><strong>OpenID Connect (OIDC)</strong> — надбудова над OAuth 2.0, що додає стандартизовану автентифікацію. OAuth 2.0 відповідає на питання «що дозволено?» (авторизація), а OIDC — «хто це?» (автентифікація). OIDC повертає ID Token (JWT з інформацією про користувача) разом з access token. UserInfo endpoint надає додаткові дані профілю. У фінансовому секторі OIDC використовується для Single Sign-On між сервісами одного банку та для Open Banking інтеграцій.</p>

        <p><strong>Session Management у фінансових системах</strong> вимагає підвищеної безпеки:</p>
        <ul>
          <li><strong>Короткий час сесії</strong> — для інтернет-банкінгу типовий таймаут 5-15 хвилин неактивності. Для високо-ризикових операцій — повторна автентифікація (step-up authentication).</li>
          <li><strong>Session fixation protection</strong> — генерація нового session ID після автентифікації для запобігання підміни сесії.</li>
          <li><strong>Secure cookie attributes</strong> — HttpOnly (захист від XSS), Secure (тільки HTTPS), SameSite=Strict (захист від CSRF), короткий Max-Age.</li>
          <li><strong>Concurrent session control</strong> — обмеження кількості одночасних сесій. Якщо оператор банку вже увійшов з одного робочого місця, вхід з іншого повинен або блокуватися, або завершити попередню сесію.</li>
          <li><strong>Binding до контексту</strong> — прив'язка сесії до IP-адреси, User-Agent, fingerprint пристрою. Зміна цих параметрів вимагає повторної автентифікації.</li>
        </ul>

        <h3>Технічний приклад: Структура JWT-токена</h3>
        <p>JWT складається з трьох частин у форматі Base64URL, розділених крапками. Нижче наведено реальний приклад декодованого токена фінансового додатку:</p>
        <pre><code># Структура JWT: header.payload.signature

# ==================== HEADER (Base64URL) ====================
# eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImZpbi0yMDI0LTAxIn0
{
  "alg": "RS256",          // Алгоритм підпису (RSA + SHA-256)
  "typ": "JWT",            // Тип токена
  "kid": "fin-2024-01"     // Key ID — ідентифікатор ключа для ротації
}

# ==================== PAYLOAD (Base64URL) ====================
# eyJzdWIiOiJ1c2VyXzEyMzQ1Iiwi... (скорочено)
{
  "sub": "user_12345",               // Subject — ID користувача
  "iss": "https://auth.bank.ua",     // Issuer — хто видав токен
  "aud": "https://api.bank.ua",      // Audience — для кого призначений
  "iat": 1706180400,                 // Issued At — час видачі (Unix timestamp)
  "exp": 1706181300,                 // Expiration — час закінчення (+15 хв)
  "jti": "a1b2c3d4-uuid",            // JWT ID — унікальний ідентифікатор
  "roles": ["cashier"],              // Ролі користувача
  "branch_id": "kyiv-001",           // Відділення (кастомний claim)
  "tx_limit": 50000,                 // Ліміт транзакцій у грн
  "scope": "read:accounts write:transactions"
}

# ==================== SIGNATURE ====================
# RSA-SHA256(
#   base64url(header) + "." + base64url(payload),
#   privateKey
# )
# Сервер перевіряє підпис відповідним публічним ключем

# УВАГА: payload НЕ зашифрований, лише закодований в Base64!
# Будь-хто може декодувати: echo "eyJzdWIi..." | base64 -d
# Ніколи не зберігайте конфіденційні дані (пароль, ПІН) у payload
</code></pre>

        <h3>Технічний приклад: OAuth 2.0 Authorization Code Flow з PKCE</h3>
        <p>Цей потік використовується для безпечної авторизації у Open Banking (PSD2), коли фінтех-додаток отримує доступ до банківського акаунту клієнта:</p>
        <pre><code># Python — OAuth 2.0 Authorization Code Flow з PKCE
# Сценарій: FinTech-додаток отримує доступ до рахунків через Open Banking API

import hashlib
import base64
import secrets
import requests

# ===== Крок 1: Генерація PKCE параметрів (клієнтський додаток) =====
code_verifier = secrets.token_urlsafe(64)  # 43-128 символів
# e.g., "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk..."

code_challenge = base64.urlsafe_b64encode(
    hashlib.sha256(code_verifier.encode()).digest()
).rstrip(b'=').decode()
# S256 хеш verifier — сервер перевірить пізніше

# ===== Крок 2: Перенаправлення користувача на Authorization Server =====
auth_url = (
    "https://auth.bank.ua/oauth2/authorize?"
    "response_type=code"
    "&client_id=fintech_app_001"
    "&redirect_uri=https://app.fintech.ua/callback"
    "&scope=accounts:read transactions:read"
    "&state=xYz789_anti_csrf_token"       # Захист від CSRF
    f"&code_challenge={code_challenge}"
    "&code_challenge_method=S256"
)
# Користувач автентифікується у банку та надає згоду

# ===== Крок 3: Банк перенаправляє назад з authorization code =====
# GET https://app.fintech.ua/callback?code=AUTH_CODE_abc123&state=xYz789...
authorization_code = "AUTH_CODE_abc123"

# ===== Крок 4: Обмін code на access token (server-to-server) =====
token_response = requests.post(
    "https://auth.bank.ua/oauth2/token",
    data={
        "grant_type": "authorization_code",
        "code": authorization_code,
        "redirect_uri": "https://app.fintech.ua/callback",
        "client_id": "fintech_app_001",
        "client_secret": "CLIENT_SECRET_KEEP_SAFE",
        "code_verifier": code_verifier  # Сервер перевіряє: SHA256(verifier) == challenge
    }
)

tokens = token_response.json()
# {
#   "access_token": "eyJhbGciOiJSUzI1NiIs...",   (JWT, 15 хв)
#   "refresh_token": "dGhpcyBpcyBhIHJlZnJl...",  (opaque, 24 год)
#   "token_type": "Bearer",
#   "expires_in": 900,
#   "scope": "accounts:read transactions:read"
# }

# ===== Крок 5: Використання access token для доступу до API =====
accounts = requests.get(
    "https://api.bank.ua/v1/accounts",
    headers={"Authorization": f"Bearer {tokens['access_token']}"}
)
print(accounts.json())
# [{"iban": "UA213223130000026007233566001", "balance": 15420.50, ...}]
</code></pre>

        <h3>Технічний приклад: Безпечна конфігурація сесійних cookie</h3>
        <p>Для інтернет-банкінгу критично важливо правильно налаштувати атрибути cookie сесії. Нижче наведено приклад для Express.js (Node.js):</p>
        <pre><code>// Node.js (Express) — безпечна конфігурація сесії для банківського додатку
const express = require('express');
const session = require('express-session');
const RedisStore = require('connect-redis').default;
const redis = require('redis');

const app = express();
const redisClient = redis.createClient({ url: 'redis://localhost:6379' });

app.use(session({
  store: new RedisStore({ client: redisClient }),  // Зберігання в Redis, не в пам'яті
  name: '__Host-session',   // Префікс __Host- — додатковий захист (тільки HTTPS, без домену)
  secret: process.env.SESSION_SECRET,  // З env-змінної, мінімум 256 біт ентропії
  resave: false,
  saveUninitialized: false,

  cookie: {
    httpOnly: true,       // Недоступний для JavaScript (захист від XSS)
    secure: true,         // Тільки через HTTPS
    sameSite: 'strict',   // Захист від CSRF — cookie не надсилається з інших сайтів
    maxAge: 15 * 60 * 1000,  // 15 хвилин для інтернет-банкінгу
    path: '/',
    domain: undefined     // __Host- cookie не може мати domain
  },

  // Генерація криптографічно стійкого session ID
  genid: () => require('crypto').randomBytes(32).toString('hex'),

  // Регенерація session ID після автентифікації (захист від session fixation)
  rolling: true  // Оновлювати maxAge при кожному запиті
}));

// Захист від session fixation — нова сесія після логіну
app.post('/login', async (req, res) => {
  const user = await authenticate(req.body.username, req.body.password);
  if (user) {
    req.session.regenerate((err) => {  // КРИТИЧНО: новий session ID
      req.session.userId = user.id;
      req.session.role = user.role;
      req.session.ip = req.ip;         // Binding до IP
      req.session.ua = req.get('User-Agent');  // Binding до User-Agent
      res.json({ success: true });
    });
  }
});

// Middleware перевірки контексту сесії
app.use((req, res, next) => {
  if (req.session.userId) {
    if (req.session.ip !== req.ip || req.session.ua !== req.get('User-Agent')) {
      req.session.destroy();  // Контекст змінився — примусовий вихід
      return res.status(401).json({ error: 'Session context changed' });
    }
  }
  next();
});
</code></pre>

        <div class="control-questions">
          <h3>Контрольні запитання</h3>
          <ol>
            <li>Чому payload JWT-токена не можна вважати конфіденційним, і які дані категорично заборонено зберігати у payload фінансового токена?</li>
            <li>Опишіть атаку Algorithm Confusion (RS256 → HS256) на JWT. Яким чином сервер повинен захищатися від цієї вразливості?</li>
            <li>У чому полягає роль PKCE (Proof Key for Code Exchange) у OAuth 2.0? Від яких атак він захищає і чому це критично для мобільних банківських додатків?</li>
            <li>Поясніть, чому JWT-токени не мають вбудованого механізму відкликання (revocation). Які стратегії використовуються для вирішення цієї проблеми у фінансових системах?</li>
            <li>Для чого використовуються атрибути HttpOnly, Secure та SameSite=Strict у cookie сесії інтернет-банкінгу? Від яких конкретних атак захищає кожен з них?</li>
          </ol>
        </div>
      </section>

      <!-- Section 3.3 -->
      <section>
        <h2>3.3 Моделі авторизації: RBAC, ABAC, ReBAC</h2>

        <p>Якщо автентифікація відповідає на питання «хто ви?», то авторизація визначає «що вам дозволено робити?». У фінансовому секторі правильна модель авторизації запобігає ситуаціям, коли касир може схвалювати кредити, а стажер — переглядати конфіденційні дані VIP-клієнтів.</p>

        <p><strong>RBAC (Role-Based Access Control)</strong> — найпоширеніша модель авторизації. Доступ надається не окремим користувачам, а ролям, які потім призначаються користувачам.</p>
        <ul>
          <li><strong>Принцип роботи:</strong> визначаються ролі (касир, менеджер, аудитор, адміністратор), кожній ролі призначається набір дозволів (permissions), користувачу призначається одна або кілька ролей.</li>
          <li><strong>Приклад у банку:</strong> роль «Касир» має дозволи: view_account, create_transaction (до 50 000 грн); роль «Менеджер» додає: approve_transaction, view_reports; роль «Аудитор» має: view_all_transactions, generate_reports, але не може створювати транзакції.</li>
          <li><strong>Ієрархічний RBAC</strong> — ролі можуть успадковувати дозволи: «Старший касир» включає всі дозволи «Касир» плюс додаткові.</li>
          <li><strong>Обмеження RBAC:</strong> role explosion — у великих організаціях кількість ролей зростає експоненціально, коли потрібно враховувати комбінації відділів, регіонів, типів клієнтів. Банк з 10 відділеннями, 5 департаментами та 4 рівнями доступу потенційно потребує 200 ролей.</li>
        </ul>

        <p><strong>ABAC (Attribute-Based Access Control)</strong> — більш гнучка модель, де рішення про доступ приймається на основі атрибутів суб'єкта, об'єкта, дії та контексту.</p>
        <ul>
          <li><strong>Атрибути суб'єкта:</strong> відділ, посада, рівень допуску, сертифікації.</li>
          <li><strong>Атрибути об'єкта:</strong> тип даних, рівень конфіденційності, власник.</li>
          <li><strong>Атрибути середовища:</strong> час доби, IP-адреса, геолокація, рівень ризику.</li>
          <li><strong>Приклад політики:</strong> «Менеджер з департаменту кредитування може схвалювати кредити до 1 000 000 грн у робочий час (09:00-18:00) з корпоративної мережі для клієнтів свого відділення».</li>
          <li><strong>Переваги:</strong> одна політика замінює десятки ролей RBAC; динамічне прийняття рішень на основі контексту; легше реалізувати принцип найменших привілеїв.</li>
        </ul>

        <p><strong>ReBAC (Relationship-Based Access Control)</strong> — модель, де доступ визначається відносинами між сутностями. Натхнення: Google Zanzibar — система авторизації, що обслуговує мільярди перевірок для Google Drive, YouTube, Cloud.</p>
        <ul>
          <li><strong>Принцип:</strong> замість «User має Role» — «User має Relationship з Object». Наприклад: «Іванов є менеджером клієнта Петренко» → Іванов може переглядати рахунки Петренко.</li>
          <li><strong>Застосування у FinTech:</strong> банківський менеджер бачить дані лише своїх клієнтів; сімейні акаунти — батько має доступ до акаунту дитини; корпоративний банкінг — CFO має доступ до всіх рахунків компанії, а бухгалтер — лише до операційного.</li>
          <li><strong>Інструменти:</strong> OpenFGA (open-source реалізація Zanzibar), SpiceDB, Ory Keto.</li>
        </ul>

        <p><strong>Policy-as-Code та Open Policy Agent (OPA).</strong> Сучасний підхід — описувати політики авторизації як код, що зберігається у Git, проходить code review та автоматично розгортається. OPA (Open Policy Agent) — найпопулярніший engine для Policy-as-Code. Політики пишуться мовою Rego:</p>
        <ul>
          <li>Єдина точка прийняття рішень для мікросервісів, API, Kubernetes, Terraform.</li>
          <li>Версіонування політик через Git — аудит змін, rollback, approval process.</li>
          <li>Тестування політик як звичайного коду — unit-тести для правил авторизації.</li>
          <li>Decoupling — зміна політик без перерозгортання сервісів.</li>
        </ul>

        <h3>Технічний приклад: Визначення RBAC-політики</h3>
        <p>Нижче наведено приклад конфігурації RBAC для банківської системи, де ролі визначаються декларативно з ієрархією та обмеженнями:</p>
        <pre><code># YAML — визначення RBAC-політик для банківської системи
# Файл: rbac-policy.yaml

roles:
  # Базова роль — касир відділення
  cashier:
    description: "Касир банківського відділення"
    permissions:
      - accounts:read            # Перегляд рахунків клієнтів
      - transactions:create      # Створення транзакцій
      - transactions:read        # Перегляд транзакцій
    constraints:
      max_transaction_amount: 50000     # Ліміт 50 000 грн
      allowed_hours: "08:00-20:00"      # Тільки в робочий час
      branch_scope: "own_branch"        # Лише своє відділення

  # Старший касир — успадковує дозволи касира
  senior_cashier:
    inherits: cashier                   # Ієрархічний RBAC
    permissions:
      - transactions:cancel             # Скасування транзакцій
      - cashier:supervise               # Нагляд за касирами
    constraints:
      max_transaction_amount: 200000    # Підвищений ліміт

  # Менеджер відділення
  branch_manager:
    inherits: senior_cashier
    permissions:
      - credits:approve                 # Схвалення кредитів
      - reports:generate                # Генерація звітів
      - employees:manage                # Управління персоналом відділення
    constraints:
      max_credit_amount: 1000000
      branch_scope: "own_branch"

  # Аудитор — лише читання, без права на операції
  auditor:
    permissions:
      - accounts:read
      - transactions:read
      - credits:read
      - reports:read
      - audit_logs:read                 # Доступ до журналів аудиту
    constraints:
      branch_scope: "all_branches"      # Усі відділення
      read_only: true                   # Жодних модифікацій

# Конфліктуючі ролі (Separation of Duties)
mutually_exclusive:
  - [cashier, auditor]                  # Касир не може бути аудитором
  - [credits:approve, credits:create]   # Той, хто створює, не схвалює

# Призначення ролей
assignments:
  - user: "ivanov@bank.ua"
    roles: [cashier]
    branch: "kyiv-001"
  - user: "petrenko@bank.ua"
    roles: [branch_manager]
    branch: "kyiv-001"
</code></pre>

        <h3>Технічний приклад: ABAC-правило на мові Rego (Open Policy Agent)</h3>
        <p>OPA дозволяє описувати складні політики авторизації як код. Нижче наведено приклад ABAC-політики для фінансової системи:</p>
        <pre><code># Rego (Open Policy Agent) — ABAC-політика для банківської системи
# Файл: policy/financial_access.rego

package bank.authz

import future.keywords.if
import future.keywords.in

# За замовчуванням — доступ заборонено
default allow := false

# Правило: менеджер може схвалювати кредити у робочий час з корпоративної мережі
allow if {
    input.action == "approve_credit"
    input.subject.department == "credit_department"
    input.subject.position in ["manager", "senior_manager"]

    # Сума кредиту не перевищує ліміт для посади
    input.resource.amount <= position_limit[input.subject.position]

    # Тільки в робочий час (09:00 - 18:00)
    current_hour := time.clock(time.now_ns())[0]
    current_hour >= 9
    current_hour < 18

    # Тільки з корпоративної мережі
    net.cidr_contains("10.0.0.0/8", input.context.ip_address)

    # Клієнт належить до відділення менеджера
    input.resource.client_branch == input.subject.branch_id
}

# Ліміти за посадою (у грн)
position_limit := {
    "manager": 1000000,        # 1 млн грн
    "senior_manager": 5000000, # 5 млн грн
}

# Правило: аудитор може переглядати будь-які дані цілодобово
allow if {
    input.action == "read"
    input.subject.role == "auditor"
    input.subject.has_valid_certificate == true
}

# Правило: блокування доступу з країн під санкціями
deny if {
    input.context.geo_country in ["RU", "BY", "KP", "IR"]
}

# Фінальне рішення: allow AND NOT deny
authorized if {
    allow
    not deny
}

# ------- Тестування політики (OPA unit test) -------
# Файл: policy/financial_access_test.rego

# test_manager_can_approve_credit_in_working_hours
test_allow_credit_approval if {
    authorized with input as {
        "action": "approve_credit",
        "subject": {
            "department": "credit_department",
            "position": "manager",
            "branch_id": "kyiv-001",
            "has_valid_certificate": true
        },
        "resource": {
            "amount": 500000,
            "client_branch": "kyiv-001"
        },
        "context": {
            "ip_address": "10.1.5.42",
            "geo_country": "UA"
        }
    }
}
</code></pre>

        <h3>Порівняння моделей авторизації: RBAC, ABAC, ReBAC</h3>
        <table border="1" cellpadding="8" cellspacing="0" style="width:100%; border-collapse: collapse; margin: 1em 0;">
          <thead>
            <tr style="background: var(--accent-light);">
              <th>Критерій</th>
              <th>RBAC</th>
              <th>ABAC</th>
              <th>ReBAC</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Основа рішення</strong></td>
              <td>Роль користувача</td>
              <td>Атрибути суб'єкта, об'єкта, контексту</td>
              <td>Відносини між сутностями</td>
            </tr>
            <tr>
              <td><strong>Гнучкість</strong></td>
              <td>Низька — жорсткі ролі</td>
              <td>Висока — динамічні правила</td>
              <td>Висока — граф відносин</td>
            </tr>
            <tr>
              <td><strong>Масштабованість</strong></td>
              <td>Role explosion у великих організаціях</td>
              <td>Складність політик зростає</td>
              <td>Добре масштабується (Google Zanzibar)</td>
            </tr>
            <tr>
              <td><strong>Складність впровадження</strong></td>
              <td>Проста</td>
              <td>Середня — висока</td>
              <td>Висока</td>
            </tr>
            <tr>
              <td><strong>Контекстні рішення</strong></td>
              <td>Ні (тільки роль)</td>
              <td>Так (час, IP, геолокація...)</td>
              <td>Частково (через відносини)</td>
            </tr>
            <tr>
              <td><strong>Аудит</strong></td>
              <td>Простий — хто має яку роль</td>
              <td>Складний — треба аналізувати правила</td>
              <td>Середній — граф відносин</td>
            </tr>
            <tr>
              <td><strong>Приклад у фінансах</strong></td>
              <td>Касир, менеджер, аудитор</td>
              <td>Кредит до 1 млн у робочий час з офісу</td>
              <td>Менеджер бачить лише своїх клієнтів</td>
            </tr>
            <tr>
              <td><strong>Інструменти</strong></td>
              <td>Keycloak, Active Directory</td>
              <td>OPA, AWS IAM, XACML</td>
              <td>OpenFGA, SpiceDB, Ory Keto</td>
            </tr>
          </tbody>
        </table>

        <div class="control-questions">
          <h3>Контрольні запитання</h3>
          <ol>
            <li>Що таке «role explosion» у моделі RBAC і чому ця проблема є особливо гострою для великих банків з розгалуженою мережею відділень?</li>
            <li>Наведіть приклад ABAC-політики для фінансової системи, яка враховує щонайменше чотири атрибути (суб'єкт, об'єкт, дія, контекст).</li>
            <li>Як модель ReBAC на основі Google Zanzibar вирішує проблему авторизації у корпоративному банкінгу, де CFO, бухгалтер та менеджер мають різні рівні доступу до рахунків?</li>
            <li>У чому переваги підходу Policy-as-Code порівняно з налаштуванням авторизації через графічний інтерфейс? Як це допомагає проходити аудит?</li>
            <li>Порівняйте RBAC та ABAC: у яких сценаріях фінансового сектору кожна з моделей є більш доцільною?</li>
          </ol>
        </div>
      </section>

      <!-- Section 3.4 -->
      <section>
        <h2>3.4 IAM та управління привілейованим доступом</h2>

        <p>Identity and Access Management (IAM) — це комплексна система управління ідентичностями, автентифікацією та авторизацією в організації. У фінансовому секторі IAM є критичною інфраструктурою: він визначає, хто має доступ до чого, від моменту прийому на роботу до звільнення.</p>

        <p><strong>Identity Lifecycle Management</strong> — управління повним циклом життя ідентичності:</p>
        <ol>
          <li><strong>Joiner (приєднання)</strong> — новий співробітник отримує акаунти, ролі та доступ відповідно до посади. Автоматичний provisioning через інтеграцію IAM з HR-системою: дані з SAP HR → автоматичне створення акаунтів у Active Directory, банківських системах, email.</li>
          <li><strong>Mover (переміщення)</strong> — при зміні посади або відділу доступи повинні бути переглянуті. Попередні дозволи відкликаються, нові надаються. Типова проблема: privilege creep — накопичення зайвих дозволів при переміщеннях без належного відкликання старих.</li>
          <li><strong>Leaver (звільнення)</strong> — негайне блокування всіх акаунтів. У фінансовому секторі це критично: звільнений працівник з активними credentials — це інсайдерська загроза. SLA на деактивацію має бути мінімальним (хвилини, не дні).</li>
        </ol>

        <p><strong>Single Sign-On (SSO) та Federation.</strong> SSO дозволяє користувачу автентифікуватися один раз і отримати доступ до всіх пов'язаних систем без повторного входу. Federation розширює SSO за межі організації:</p>
        <ul>
          <li><strong>SAML 2.0</strong> — XML-based протокол для SSO між організаціями. Широко використовується у корпоративному середовищі та B2B-інтеграціях фінансового сектору.</li>
          <li><strong>OIDC Federation</strong> — сучасна альтернатива SAML, базована на OAuth 2.0/OIDC. Простіша реалізація, кращий досвід для мобільних додатків.</li>
          <li><strong>SCIM (System for Cross-domain Identity Management)</strong> — протокол автоматичної синхронізації ідентичностей між системами. Коли HR створює або деактивує запис — SCIM автоматично синхронізує зміни з усіма підключеними системами.</li>
        </ul>

        <p><strong>PAM (Privileged Access Management)</strong> — управління привілейованими акаунтами (root, admin, DBA, системні акаунти), які мають розширений доступ до критичних систем. Компрометація привілейованого акаунту — це найкоротший шлях до катастрофи: за даними Forrester, 80% порушень безпеки пов'язані з привілейованим доступом.</p>
        <ul>
          <li><strong>Password Vault</strong> — централізоване зберігання паролів привілейованих акаунтів у зашифрованому сховищі. Адміністратори не знають паролів — вони «витягуються» з vault автоматично для кожної сесії. CyberArk, HashiCorp Vault, Delinea — лідери ринку PAM.</li>
          <li><strong>Session Recording</strong> — запис усіх дій привілейованих користувачів. Кожна команда адміністратора в production-середовищі логується для аудиту та розслідувань.</li>
          <li><strong>Just-in-Time (JIT) Access</strong> — привілейований доступ надається лише на час виконання конкретного завдання, після чого автоматично відкликається. Замість постійного root-доступу — запит на 2 години для оновлення системи.</li>
          <li><strong>Secrets Management</strong> — HashiCorp Vault зберігає API-ключі, credentials баз даних, сертифікати. Автоматична ротація секретів: пароль до бази даних змінюється кожні 24 години без втручання людини.</li>
        </ul>

        <p><strong>Розділення обов'язків (Separation of Duties — SoD)</strong> — принцип, що вимагає участі кількох осіб для завершення критичної операції, запобігаючи шахрайству та помилкам:</p>
        <ul>
          <li><strong>Статичне SoD</strong> — одна людина не може мати конфліктуючі ролі. Наприклад: особа, яка створює платіжне доручення, не може його схвалювати; розробник не має прямого доступу до production.</li>
          <li><strong>Динамічне SoD</strong> — обмеження на рівні транзакцій: один оператор може створити переказ, але для переказу понад 100 000 грн потрібно підтвердження другого оператора (dual control).</li>
          <li><strong>Кейс:</strong> у системі SWIFT обов'язковим є принцип 4-eyes — кожен переказ повинен бути ініційований одним оператором та схвалений іншим. Після атаки на Bangladesh Bank (2016) SWIFT посилив вимоги до SoD та впровадив обов'язковий dual authorization для переказів понад визначений ліміт.</li>
        </ul>

        <p><strong>Periodic Access Review (рекапітуляція доступу)</strong> — регулярний (щоквартальний або щорічний) перегляд усіх наданих доступів. Менеджери та власники систем підтверджують або відкликають доступ для кожного користувача. Це вимога регуляторів (PCI DSS Requirement 7, SOX, НБУ) та ефективний спосіб виявлення orphaned accounts та надлишкових привілеїв.</p>

        <h3>Технічний приклад: SCIM-провізіонінг через REST API</h3>
        <p>Протокол SCIM (RFC 7644) автоматизує управління ідентичностями між HR-системою та корпоративними сервісами. Нижче наведено типові операції:</p>
        <pre><code># SCIM 2.0 — автоматичний provisioning при прийомі на роботу
# HR-система створює запис → SCIM автоматично створює акаунти

# ===== Крок 1: Створення нового користувача (Joiner) =====
# POST https://iam.bank.ua/scim/v2/Users
# Content-Type: application/scim+json
# Authorization: Bearer &lt;scim_service_token&gt;

{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User",
               "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User"],
  "userName": "kovalenko@bank.ua",
  "name": {
    "givenName": "Олена",
    "familyName": "Коваленко"
  },
  "emails": [
    { "value": "kovalenko@bank.ua", "type": "work", "primary": true }
  ],
  "active": true,
  "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User": {
    "employeeNumber": "EMP-2024-0847",
    "department": "Credit Department",
    "manager": {
      "$ref": "https://iam.bank.ua/scim/v2/Users/mgr-001",
      "value": "mgr-001",
      "displayName": "Петренко Ігор"
    },
    "division": "Київське відділення №1"
  },
  "roles": [
    { "value": "credit_analyst", "type": "default" }
  ]
}

# Відповідь: 201 Created
# IAM автоматично створює: AD-акаунт, email, доступ до банківської системи

# ===== Крок 2: Зміна посади (Mover) — PATCH =====
# PATCH https://iam.bank.ua/scim/v2/Users/user-847
{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [
    {
      "op": "replace",
      "path": "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User:department",
      "value": "Risk Management"
    },
    {
      "op": "remove",
      "path": "roles[value eq \"credit_analyst\"]"
    },
    {
      "op": "add",
      "path": "roles",
      "value": [{ "value": "risk_analyst", "type": "default" }]
    }
  ]
}
# Старі ролі відкликано, нові надано автоматично

# ===== Крок 3: Звільнення (Leaver) — деактивація =====
# PATCH https://iam.bank.ua/scim/v2/Users/user-847
{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [
    { "op": "replace", "path": "active", "value": false }
  ]
}
# Усі акаунти та доступи блоковано протягом хвилин, не днів
</code></pre>

        <h3>Технічний приклад: Конфігурація PAM з записом сесій</h3>
        <p>Привілейований доступ у фінансових системах має бути контрольованим — кожна дія адміністратора записується для аудиту:</p>
        <pre><code># HashiCorp Vault — конфігурація PAM для банківської інфраструктури
# Файл: vault-pam-config.hcl

# ===== Динамічні credentials для бази даних =====
# Vault генерує тимчасові облікові дані для кожної сесії
resource "vault_database_secret_backend_role" "db_admin" {
  backend             = "database"
  name                = "prod-db-admin"
  db_name             = "core-banking-db"

  # Тимчасові credentials з обмеженим TTL
  default_ttl         = "1h"        # 1 година за замовчуванням
  max_ttl             = "4h"        # Максимум 4 години
  creation_statements = [
    "CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';",
    "GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA banking TO \"{{name}}\";",
    "ALTER ROLE \"{{name}}\" SET log_statement = 'all';"  # Логувати ВСІ SQL-запити
  ]
  revocation_statements = [
    "DROP ROLE IF EXISTS \"{{name}}\";"  # Автоматичне видалення після TTL
  ]
}

# ===== Політика JIT (Just-in-Time) доступу =====
# Адміністратор запитує доступ → менеджер схвалює → доступ на 2 години
path "database/creds/prod-db-admin" {
  capabilities = ["read"]

  # Обов'язкове підтвердження другою особою
  required_parameters = ["reason", "ticket_id"]
  control_group {
    factor "manager_approval" {
      identity {
        group_names = ["db-managers"]
        approvals   = 1
      }
    }
    ttl = "4h"  # Час на схвалення
  }
}

# ===== Запис сесій (Session Recording) =====
# Усі SSH-сесії до production записуються
resource "boundary_target" "prod_database" {
  name        = "core-banking-prod"
  type        = "ssh"
  scope_id    = boundary_scope.banking_prod.id

  # Запис кожної команди та її виводу
  enable_session_recording = true
  storage_bucket_id        = boundary_storage_bucket.audit.id

  # Обмеження сесії
  session_max_seconds       = 7200   # Максимум 2 години
  session_connection_limit  = 1      # Одне з'єднання за сесію

  # Injection — автоматичне додавання банера
  injected_application_credential_source_ids = [
    boundary_credential_library_vault.prod_db.id
  ]
}

# ===== Аудит: кожна дія логується =====
audit "file" {
  type = "file"
  options {
    file_path = "/var/log/vault/audit.log"
    format    = "json"
    log_raw   = false   # Не логувати чутливі дані у відкритому вигляді
    hmac_accessor = true
  }
}
# Приклад запису: {"time":"2024-01-15T14:23:01Z","type":"response",
#   "auth":{"accessor":"hmac-sha256:abc...","entity_id":"user-123"},
#   "request":{"path":"database/creds/prod-db-admin",
#     "data":{"reason":"Оновлення схеми БД","ticket_id":"JIRA-4521"}}}
</code></pre>

        <h3>Технічний приклад: Матриця розділення обов'язків (SoD)</h3>
        <p>Матриця SoD визначає конфліктуючі ролі та дозволи, які не можуть бути призначені одній особі. Нижче наведено приклад для банківської системи:</p>
        <pre><code># Матриця розділення обов'язків (Separation of Duties) для банку
# X = конфлікт (ролі не можуть бути в однієї особи одночасно)
# - = допустимо

# ┌───────────────────┬──────────┬──────────┬──────────┬──────────┬───────────┬──────────┐
# │                   │ Створення│ Схвалення│ Виконання│  Аудит   │ Управління│ Адмін    │
# │                   │ платежів │ платежів │ платежів │ операцій │ клієнтами │ системи  │
# ├───────────────────┼──────────┼──────────┼──────────┼──────────┼───────────┼──────────┤
# │ Створення платежів│    -     │    X     │    X     │    X     │     -     │    X     │
# │ Схвалення платежів│    X     │    -     │    X     │    X     │     -     │    X     │
# │ Виконання платежів│    X     │    X     │    -     │    X     │     -     │    X     │
# │ Аудит операцій    │    X     │    X     │    X     │    -     │     X     │    X     │
# │ Управління клієнт.│    -     │    -     │    -     │    X     │     -     │    -     │
# │ Адмін системи     │    X     │    X     │    X     │    X     │     -     │    -     │
# └───────────────────┴──────────┴──────────┴──────────┴──────────┴───────────┴──────────┘

# Реалізація SoD-перевірки в коді (Python)
from typing import Set, Dict, Tuple

# Визначення конфліктуючих пар ролей
SOD_CONFLICTS: Set[Tuple[str, str]] = {
    ("payment_creator", "payment_approver"),       # Створювач ≠ схвалювач
    ("payment_creator", "payment_executor"),        # Створювач ≠ виконавець
    ("payment_approver", "payment_executor"),       # Схвалювач ≠ виконавець
    ("payment_creator", "auditor"),                 # Операціоніст ≠ аудитор
    ("payment_approver", "auditor"),
    ("payment_executor", "auditor"),
    ("system_admin", "payment_creator"),            # Адмін ≠ операціоніст
    ("system_admin", "payment_approver"),
    ("system_admin", "payment_executor"),
    ("system_admin", "auditor"),
    ("auditor", "client_manager"),                  # Аудитор ≠ менеджер клієнтів
}

def check_sod_violation(user_roles: Set[str], new_role: str) -> list:
    """Перевірка порушення розділення обов'язків при призначенні нової ролі."""
    violations = []
    for existing_role in user_roles:
        pair = tuple(sorted([existing_role, new_role]))
        if pair in {tuple(sorted(c)) for c in SOD_CONFLICTS}:
            violations.append(
                f"Конфлікт SoD: '{existing_role}' та '{new_role}' "
                f"не можуть бути призначені одній особі"
            )
    return violations

# Приклад використання
user_roles = {"payment_creator", "client_manager"}
new_role = "payment_approver"

violations = check_sod_violation(user_roles, new_role)
if violations:
    for v in violations:
        print(f"ЗАБОРОНЕНО: {v}")
    # ЗАБОРОНЕНО: Конфлікт SoD: 'payment_creator' та 'payment_approver'
    # не можуть бути призначені одній особі
else:
    print(f"Роль '{new_role}' може бути призначена")

# Динамічне SoD: перевірка на рівні транзакцій
def check_dynamic_sod(transaction_id: str, action: str, user_id: str) -> bool:
    """Переказ понад 100 000 грн потребує підтвердження іншою особою."""
    tx = get_transaction(transaction_id)
    if tx.amount > 100000 and action == "approve":
        if tx.created_by == user_id:
            raise PermissionError(
                f"Dual control: користувач {user_id} створив транзакцію "
                f"і не може її схвалити (сума {tx.amount} грн > 100 000 грн)"
            )
    return True
</code></pre>

        <div class="control-questions">
          <h3>Контрольні запитання</h3>
          <ol>
            <li>Опишіть три фази життєвого циклу ідентичності (Joiner-Mover-Leaver). Яка фаза є найбільш ризикованою для фінансових установ і чому?</li>
            <li>Що таке privilege creep і як механізм Periodic Access Review допомагає його виявити? Які регуляторні вимоги зобов'язують проводити рекапітуляцію доступу?</li>
            <li>Поясніть принцип Just-in-Time (JIT) Access у контексті PAM. Чому постійний root-доступ до production-середовища банку є неприйнятним?</li>
            <li>У чому різниця між статичним та динамічним розділенням обов'язків (SoD)? Наведіть приклад кожного типу для банківської системи переказів.</li>
            <li>Як атака на Bangladesh Bank (2016) вплинула на вимоги SWIFT щодо dual authorization? Які заходи SoD могли б запобігти цій атаці?</li>
          </ol>
        </div>
      </section>

      <!-- Summary -->
      <section>
        <h2>Підсумок</h2>
        <p>У цій лекції ми розглянули повний ландшафт автентифікації та контролю доступу у фінансових системах. Сучасна автентифікація еволюціонує від паролів до passwordless-рішень на основі FIDO2 та passkeys, MFA стає обов'язковим стандартом, а біометрія доповнює традиційні фактори. JWT-токени та OAuth 2.0/OIDC забезпечують безпечну авторизацію для API та мікросервісів, але вимагають правильної імплементації для уникнення критичних вразливостей.</p>
        <p>Моделі авторизації — від класичного RBAC до гнучкого ABAC та ReBAC — дозволяють реалізувати принцип найменших привілеїв на рівні, що відповідає складності фінансових організацій. IAM та PAM забезпечують управління повним циклом ідентичностей та захист привілейованого доступу, а принцип розділення обов'язків (SoD) запобігає шахрайству.</p>
        <p><strong>У наступній лекції</strong> ми розглянемо клієнтські атаки: XSS (міжсайтовий скриптинг), CSRF та інші вразливості клієнтської частини веб-додатків у контексті фінансових систем.</p>
      </section>
    </article>

    <div class="lecture-nav-bottom">
      <a href="../../lecture.html?id=3" class="nav-btn">&larr; Назад до лекції</a>
      <span></span>
    </div>

    <footer></footer>
  </main>

  <script src="../../js/main.js"></script>

</body>
</html>
