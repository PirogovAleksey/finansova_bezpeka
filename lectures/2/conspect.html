<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Конспект лекції 2: Безпечна архітектура FinTech-систем.">
  <meta name="author" content="Кафедра ТЕІБ, Ужгородський національний університет">
  <meta name="theme-color" content="#0ea5e9">
  <title>Конспект: Лекція 2 — Фінансова Безпека</title>
  <link rel="icon" type="image/svg+xml" href="../../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../css/style.css">
  <script>if(localStorage.getItem('theme')==='dark')document.documentElement.classList.add('dark')</script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
          <path d="M9 12l2 2 4-4"/>
        </svg>
      </div>
      <div class="logo-text">
        Фінансова<br>Безпека
        <span>онлайн-курс</span>
      </div>
    </div>

    <nav aria-label="Головна навігація">
      <a href="../../index.html" class="active">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../../practicals.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>
        Практичні
      </a>
      <a href="../../tests.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../../materials.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
    </nav>

    <div class="sidebar-footer">
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <main>
    <div class="lecture-nav-top">
      <a href="../../lecture.html?id=2" class="back-link">← Назад до лекції 2</a>
      <span class="lecture-badge">Конспект лекції 2</span>
    </div>

    <article class="lecture-content">
      <h1>Безпечна архітектура FinTech-систем</h1>
      <div class="lecture-info">
        <span>⏱ 2 год</span>
        <span class="badge badge-new">Конспект</span>
      </div>

      <!-- Section 2.1 -->
      <section>
        <h2>2.1 Принципи Zero Trust Architecture</h2>

        <p>Традиційна модель мережевої безпеки базувалася на концепції «периметра»: все всередині корпоративної мережі вважалося довіреним, а загрози очікувалися лише ззовні. Ця модель більше не працює у світі хмарних сервісів, віддаленої роботи та складних інтеграцій. Zero Trust Architecture (ZTA) — це сучасний підхід до безпеки, що базується на принципі «ніколи не довіряй, завжди перевіряй» (Never Trust, Always Verify).</p>

        <p><strong>Ключові принципи Zero Trust:</strong></p>
        <ul>
          <li><strong>Верифікація кожного запиту</strong> — кожен запит до ресурсу перевіряється незалежно від того, звідки він надходить: із внутрішньої мережі, VPN чи публічного інтернету. Автентифікація та авторизація відбуваються для кожної транзакції.</li>
          <li><strong>Принцип найменших привілеїв (Least Privilege)</strong> — користувачі та системи отримують лише мінімально необхідні права доступу. Just-in-Time (JIT) та Just-Enough-Access (JEA) забезпечують тимчасове надання підвищених привілеїв лише коли це необхідно.</li>
          <li><strong>Мікросегментація</strong> — мережа розділяється на ізольовані сегменти. Навіть якщо зловмисник проник в один сегмент, він не має автоматичного доступу до інших. У фінансовому секторі це критично важливо для ізоляції платіжних систем, баз даних клієнтів та адміністративних систем.</li>
          <li><strong>Assume Breach</strong> — архітектура проектується з припущенням, що компрометація вже відбулася або неминуча. Це означає посилений моніторинг, детекцію аномалій та готовність до швидкого реагування.</li>
        </ul>

        <p><strong>BeyondCorp — приклад Zero Trust від Google.</strong> Після серії атак Operation Aurora у 2009-2010 роках Google впровадив модель BeyondCorp, яка повністю відмовилась від концепції «довіреної внутрішньої мережі». Усі сервіси доступні через інтернет, але захищені потужною автентифікацією, перевіркою стану пристрою та контекстними політиками доступу. Цей підхід став еталоном для індустрії.</p>

        <p><strong>Компоненти Zero Trust у FinTech:</strong></p>
        <ol>
          <li><strong>Identity Provider (IdP)</strong> — централізоване управління ідентичностями. Усі користувачі та сервіси мають верифіковану ідентичність. Приклади: Okta, Azure AD, Auth0.</li>
          <li><strong>Policy Engine</strong> — система прийняття рішень про доступ на основі контексту: хто запитує, з якого пристрою, в який час, до якого ресурсу, який рівень ризику транзакції.</li>
          <li><strong>Policy Enforcement Point (PEP)</strong> — точки застосування політик. Кожен запит проходить через PEP, який блокує або дозволяє доступ на основі рішення Policy Engine.</li>
          <li><strong>Continuous Monitoring</strong> — постійний моніторинг поведінки користувачів та систем. Аномальна активність (наприклад, вхід з нової локації та спроба великого переказу) викликає додаткову верифікацію.</li>
        </ol>

        <p><strong>Практична реалізація у банку:</strong> Замість того щоб довіряти всьому трафіку з корпоративної мережі, кожен запит оператора до системи SWIFT перевіряється: валідність JWT-токена, відповідність ролі, стан робочої станції (антивірус оновлений, диск зашифрований), час доби (операції лише в робочий час), геолокація. Навіть авторизований оператор не зможе виконати переказ з незахищеного пристрою або в неробочий час без додаткового підтвердження.</p>
      </section>

      <!-- Section 2.2 -->
      <section>
        <h2>2.2 Secure SDLC для FinTech</h2>

        <p>Secure Software Development Life Cycle (Secure SDLC) — це інтеграція практик безпеки на кожному етапі розробки програмного забезпечення. У фінансовому секторі, де вразливість може призвести до крадіжки мільйонів, безпека повинна бути вбудована в процес, а не «прикручена» в кінці.</p>

        <p><strong>Фази Secure SDLC:</strong></p>
        <ol>
          <li><strong>Requirements (Вимоги)</strong> — на етапі збору вимог визначаються security requirements: які дані потрібно захищати (PII, PAN), які регуляторні вимоги застосовуються (PCI DSS, GDPR), які загрози актуальні для цього типу системи.</li>
          <li><strong>Design (Проєктування)</strong> — Threat Modeling: систематичний аналіз архітектури для виявлення потенційних загроз. Методології STRIDE, PASTA, Attack Trees допомагають ідентифікувати вразливості ще до написання коду.</li>
          <li><strong>Development (Розробка)</strong> — Secure Coding Guidelines: правила безпечного кодування, уникнення типових вразливостей (OWASP Top 10). Code Review з фокусом на безпеку. Використання безпечних бібліотек та фреймворків.</li>
          <li><strong>Testing (Тестування)</strong> — SAST (Static Application Security Testing) аналізує код без виконання, DAST (Dynamic Application Security Testing) тестує працюючий додаток, IAST поєднує обидва підходи, пентестування імітує реальні атаки.</li>
          <li><strong>Deployment (Розгортання)</strong> — безпечна конфігурація серверів (hardening), перевірка секретів (немає паролів у коді), Infrastructure as Code з вбудованими перевірками безпеки.</li>
          <li><strong>Maintenance (Підтримка)</strong> — моніторинг вразливостей у залежностях (Dependabot, Snyk), регулярні оновлення, реагування на CVE.</li>
        </ol>

        <p><strong>DevSecOps</strong> — це культура та практика інтеграції безпеки в DevOps-процеси. Ключова ідея: безпека — відповідальність кожного, а не лише команди безпеки. Автоматизація перевірок безпеки в CI/CD pipeline дозволяє виявляти вразливості швидко та дешево.</p>

        <p><strong>Типовий Security Pipeline у FinTech:</strong></p>
        <ul>
          <li><strong>Pre-commit hooks</strong> — перевірка на наявність секретів у коді (git-secrets, truffleHog)</li>
          <li><strong>SAST у CI</strong> — Semgrep, SonarQube, Checkmarx сканують код при кожному коміті</li>
          <li><strong>Dependency scanning</strong> — OWASP Dependency-Check, Snyk перевіряють бібліотеки на відомі вразливості</li>
          <li><strong>Container scanning</strong> — Trivy, Clair перевіряють Docker-образи</li>
          <li><strong>DAST у staging</strong> — OWASP ZAP, Burp Suite автоматично тестують API</li>
          <li><strong>Infrastructure scanning</strong> — Checkov, tfsec перевіряють Terraform/CloudFormation на misconfigurations</li>
        </ul>

        <p><strong>Threat Modeling на практиці.</strong> Для нової функції «P2P-перекази» команда проводить сесію threat modeling: малює data flow diagram, визначає trust boundaries (мобільний додаток — недовірена зона, API — напівдовірена, база даних — довірена), застосовує STRIDE до кожного компонента. Результат: список загроз з пріоритетами та контрзаходами, які стають частиною backlog розробки.</p>
      </section>

      <!-- Section 2.3 -->
      <section>
        <h2>2.3 Безпека мікросервісної архітектури</h2>

        <p>Сучасні FinTech-платформи будуються на мікросервісній архітектурі: замість одного монолітного додатку — десятки незалежних сервісів, кожен з яких відповідає за конкретну функцію (автентифікація, платежі, повідомлення, аналітика). Це дає гнучкість та масштабованість, але створює нові виклики для безпеки.</p>

        <p><strong>Виклики безпеки мікросервісів:</strong></p>
        <ul>
          <li><strong>Розширена поверхня атаки</strong> — більше сервісів = більше точок входу. Кожен сервіс має свій API, який може бути атакований.</li>
          <li><strong>Міжсервісна комунікація</strong> — сервіси постійно обмінюються даними. Без належного захисту зловмисник, що проник в один сервіс, може атакувати інші.</li>
          <li><strong>Управління секретами</strong> — кожен сервіс потребує credentials для доступу до баз даних, API-ключів, сертифікатів. Управління сотнями секретів — складне завдання.</li>
          <li><strong>Консистентність політик</strong> — забезпечити однакові стандарти безпеки для всіх сервісів, які можуть розроблятися різними командами.</li>
        </ul>

        <p><strong>Service Mesh</strong> — це інфраструктурний шар, який забезпечує безпечну комунікацію між сервісами. Популярні реалізації: Istio, Linkerd, Consul Connect. Service mesh надає:</p>
        <ul>
          <li><strong>mTLS (Mutual TLS)</strong> — автоматичне шифрування та взаємна автентифікація між сервісами. Кожен сервіс має сертифікат, і обидві сторони перевіряють один одного.</li>
          <li><strong>Політики авторизації</strong> — правила, які сервіси можуть викликати інші сервіси. Наприклад: тільки payment-service може звертатися до banking-gateway.</li>
          <li><strong>Observability</strong> — автоматичний збір метрик, логів та traces для аналізу безпеки.</li>
        </ul>

        <p><strong>Безпека контейнерів та Kubernetes:</strong></p>
        <ol>
          <li><strong>Захист образів</strong> — використовуйте лише перевірені base images, скануйте на вразливості (Trivy, Clair), підписуйте образи (Notary, Cosign).</li>
          <li><strong>Runtime Security</strong> — обмежте можливості контейнера: не запускайте як root, заборонйте privilege escalation, використовуйте read-only filesystem де можливо.</li>
          <li><strong>Network Policies</strong> — за замовчуванням забороніть весь трафік між подами, дозвольте лише необхідний (принцип default deny).</li>
          <li><strong>Pod Security Standards</strong> — Kubernetes 1.25+ має вбудовані рівні безпеки: Privileged, Baseline, Restricted. Для FinTech-workloads використовуйте Restricted.</li>
          <li><strong>Secrets Management</strong> — не зберігайте секрети в ConfigMaps або env variables у відкритому вигляді. Використовуйте HashiCorp Vault, AWS Secrets Manager, Azure Key Vault з автоматичною ротацією.</li>
        </ol>

        <p><strong>Приклад архітектури безпеки FinTech-платформи:</strong> API Gateway (Kong/AWS API Gateway) на вході обробляє автентифікацію та rate limiting. Далі запит потрапляє в service mesh (Istio), де mTLS шифрує комунікацію. Кожен сервіс запускається в Kubernetes з Restricted pod security та Network Policies. Секрети (API-ключі платіжних систем, credentials до баз) зберігаються у Vault та інжектуються при старті контейнера. Весь трафік логується та відправляється в SIEM для аналізу.</p>
      </section>

      <!-- Section 2.4 -->
      <section>
        <h2>2.4 Захист API та інтеграцій</h2>

        <p>API є серцем сучасних FinTech-систем. Через API мобільні додатки взаємодіють з backend, партнери інтегруються з платіжними системами, внутрішні сервіси обмінюються даними. Незахищене API — це відкриті двері для зловмисників.</p>

        <p><strong>OWASP API Security Top 10 (2023):</strong></p>
        <ol>
          <li><strong>Broken Object Level Authorization (BOLA)</strong> — зловмисник маніпулює ідентифікаторами об'єктів для доступу до чужих даних. Приклад: зміна account_id у запиті для перегляду балансу іншого клієнта.</li>
          <li><strong>Broken Authentication</strong> — слабкі механізми автентифікації: передбачувані токени, відсутність rate limiting на login, витік токенів.</li>
          <li><strong>Broken Object Property Level Authorization</strong> — масове присвоєння (mass assignment): клієнт може змінювати поля, до яких не повинен мати доступу (наприклад, role: admin).</li>
          <li><strong>Unrestricted Resource Consumption</strong> — відсутність лімітів на кількість запитів, розмір payload, що дозволяє DoS-атаки.</li>
          <li><strong>Broken Function Level Authorization</strong> — звичайний користувач може викликати адміністративні endpoint.</li>
        </ol>

        <p><strong>OAuth 2.0 та OpenID Connect</strong> — стандарти авторизації та автентифікації для API. У FinTech-контексті:</p>
        <ul>
          <li><strong>Authorization Code Flow з PKCE</strong> — рекомендований flow для мобільних та SPA-додатків. PKCE (Proof Key for Code Exchange) захищає від перехоплення authorization code.</li>
          <li><strong>Client Credentials Flow</strong> — для server-to-server комунікації між внутрішніми сервісами.</li>
          <li><strong>Scopes</strong> — обмежують права токена. Наприклад: read:balance дозволяє лише читати баланс, але не робити перекази.</li>
          <li><strong>Token Binding</strong> — прив'язка токена до конкретного клієнта (mTLS client certificate) для запобігання крадіжці.</li>
        </ul>

        <p><strong>API Gateway як точка захисту:</strong> Централізований API Gateway (Kong, AWS API Gateway, Apigee) забезпечує:</p>
        <ul>
          <li><strong>Rate Limiting</strong> — обмеження кількості запитів на клієнта/IP. Для FinTech критично мати різні ліміти: 100 req/min для звичайних операцій, 5 req/min для переказів.</li>
          <li><strong>Request Validation</strong> — перевірка структури запиту на відповідність OpenAPI-схемі ще до того, як він досягне backend.</li>
          <li><strong>WAF Integration</strong> — Web Application Firewall блокує типові атаки: SQL injection, XSS, path traversal.</li>
          <li><strong>Logging & Monitoring</strong> — логування всіх запитів для аудиту та виявлення аномалій.</li>
        </ul>

        <p><strong>Безпека Webhook та асинхронних інтеграцій:</strong> Багато FinTech-інтеграцій використовують webhooks — зворотні виклики від зовнішніх систем (Stripe, Plaid, платіжні процесори). Захист webhooks:</p>
        <ul>
          <li><strong>Signature Verification</strong> — кожен webhook підписується секретним ключем. Перевіряйте HMAC-підпис перед обробкою.</li>
          <li><strong>IP Whitelisting</strong> — приймайте webhooks лише з відомих IP-адрес провайдера.</li>
          <li><strong>Replay Protection</strong> — використовуйте timestamp у підписі та відхиляйте застарілі запити (> 5 хвилин).</li>
          <li><strong>Idempotency</strong> — обробляйте кожен webhook рівно один раз, навіть якщо він прийде повторно.</li>
        </ul>

        <p><strong>Input Validation — остання лінія оборони.</strong> Навіть за наявності API Gateway та WAF, кожен сервіс повинен валідувати вхідні дані:</p>
        <ul>
          <li>Перевіряйте типи даних (amount — число, не рядок)</li>
          <li>Перевіряйте діапазони (amount > 0 та amount <= max_transfer_limit)</li>
          <li>Використовуйте whitelist для enum-полів (currency IN ['UAH', 'USD', 'EUR'])</li>
          <li>Санітизуйте рядки перед використанням у SQL, HTML, shell commands</li>
        </ul>
      </section>

      <!-- Summary -->
      <section>
        <h2>Підсумок</h2>
        <p>У цій лекції ми розглянули фундаментальні принципи побудови безпечної архітектури FinTech-систем. Zero Trust Architecture забезпечує захист у світі без периметра, Secure SDLC інтегрує безпеку на кожному етапі розробки, мікросервісна архітектура з service mesh та Kubernetes security захищає runtime-середовище, а правильно реалізовані API-механізми захищають точки інтеграції.</p>
        <p>Ключовий висновок: безпека — це не продукт, а процес. Вона повинна бути вбудована в архітектуру з першого дня, а не додана як afterthought. Defense in depth — багаторівневий захист — забезпечує стійкість навіть при компрометації окремих компонентів.</p>
        <p><strong>У наступній лекції</strong> ми розглянемо механізми автентифікації та контролю доступу: від паролів та MFA до OAuth 2.0 та RBAC/ABAC моделей авторизації у фінансових системах.</p>
      </section>
    </article>

    <div class="lecture-nav-bottom">
      <a href="../../lecture.html?id=2" class="nav-btn">← Назад до лекції</a>
      <span></span>
    </div>

    <footer></footer>
  </main>

  <script src="../../js/main.js"></script>

</body>
</html>
